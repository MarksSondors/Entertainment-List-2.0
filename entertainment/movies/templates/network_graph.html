{% extends "components/base.html" %}
{% load static %}

{% block title %}Movie Network Graph{% endblock %}

{% block content %}
<style>
/* Retro theme variables (aligned with other pages) */
:root {
	--bg-color: #c0c0c0;
	--text-color: #000;
	--text-muted: #444;
	--border-dark: #808080;
	--border-light: #dfdfdf;
	--window-bg: #c0c0c0;
	--button-bg: #c0c0c0;
	--button-text: #000;
	--button-hover: #e0e0e0;
	--shadow-color: rgba(0,0,0,0.3);
}

@media (prefers-color-scheme: dark) {
	:root {
		--bg-color: #383838;
		--text-color: #fff;
		--text-muted: #b0b0b0;
		--border-dark: #2a2a2a;
		--border-light: #505050;
		--window-bg: #404040;
		--button-bg: #505050;
		--button-text: #fff;
		--button-hover: #606060;
		--shadow-color: rgba(0,0,0,0.5);
	}
}

.network-page-container { max-width: 1400px; margin: 0 auto; padding: 20px; }

.window { border: 2px outset var(--bg-color); background: var(--window-bg); font-family: 'MS Sans Serif', sans-serif; box-shadow: 2px 2px 4px var(--shadow-color); margin-bottom: 20px; }
.title-bar { background: linear-gradient(90deg, #0f0f81 0%, #1084d0 100%); color:#fff; padding:2px 6px; font-size:11px; font-weight:bold; display:flex; justify-content:space-between; align-items:center; }
@media (prefers-color-scheme: dark) { .title-bar { background: linear-gradient(90deg,#1a1a3a 0%, #2060a0 100%);} }
.title-bar-controls button { width:16px; height:14px; border:1px outset var(--button-bg); background: var(--button-bg); font-size:8px; cursor:pointer; }
.title-bar-controls button:active { border:1px inset var(--button-bg); }
.window-body { padding:12px; color: var(--text-color); background: var(--window-bg); }

.retro-btn { border:1px outset var(--button-bg); background: var(--button-bg); color:var(--button-text); padding:2px 10px; font-size:12px; cursor:pointer; text-decoration:none; display:inline-block; }
.retro-btn:hover { background: var(--button-hover); text-decoration:none; }
.retro-btn:active { border:1px inset var(--button-bg); }

/* Layout */
.graph-layout { display: grid; grid-template-columns: 320px 1fr; gap: 20px; }
@media (max-width: 1100px) { .graph-layout { grid-template-columns: 1fr; } }

.panel { margin-bottom: 20px; }
.panel h3 { margin:0 0 8px 0; font-size:14px; }
.muted { color: var(--text-muted); font-size: 12px; }

/* Controls */
.control-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(140px,1fr)); gap:10px; }
.control-item { display:flex; flex-direction:column; gap:4px; font-size:11px; }
.control-item input, .control-item select { padding:4px; font-size:12px; border:1px solid var(--border-dark); background: var(--button-bg); color: var(--text-color); }

/* Chaos Mode Button */
.flame-btn {
		position: relative;
		border: 2px outset #b22222;
		background: linear-gradient(180deg,#ff7b00 0%,#ff4500 60%,#8b0000 100%);
		color: #fff;
		font-weight: bold;
		font-size: 12px;
		padding: 6px 10px 6px 30px; /* space for flame icon */
		cursor: pointer;
		text-transform: uppercase;
		letter-spacing: 1px;
		box-shadow: 0 0 6px rgba(255,80,0,0.6), 0 0 12px rgba(255,140,0,0.4);
		overflow: hidden;
		transition: filter .25s, transform .1s, box-shadow .3s;
}
.flame-btn:active { border:2px inset #b22222; transform: translateY(1px); }
.flame-btn:hover { filter: brightness(1.1); box-shadow: 0 0 8px rgba(255,120,0,0.9), 0 0 18px rgba(255,80,0,0.6); }
.flame-btn.active { background: linear-gradient(180deg,#ffe066 0%,#ff8c00 40%,#ff4500 70%,#650000 100%); box-shadow: 0 0 10px 4px rgba(255,160,0,0.8), 0 0 25px rgba(255,50,0,0.7); }

/* Animated flame pseudo */
.flame-btn::before {
	content: '\1F525'; /* single fire emoji */
	position: absolute;
	left: 8px;
	top: 50%;
	transform: translateY(-50%) scale(1);
	animation: flicker 1s infinite ease-in-out;
	filter: drop-shadow(0 0 4px rgba(255,150,0,0.9));
	font-size: 16px;
}

@keyframes flicker {
	0%,100% { transform: translateY(-50%) scale(1) rotate(-2deg); opacity:1; }
	20% { transform: translateY(-48%) scale(1.05) rotate(2deg); }
	40% { transform: translateY(-52%) scale(0.95) rotate(-1deg); opacity:.85; }
	60% { transform: translateY(-49%) scale(1.08) rotate(1deg); }
	80% { transform: translateY(-51%) scale(0.98) rotate(-2deg); opacity:.9; }
}

/* Ember particles */
.flame-btn .embers span { position:absolute; width:4px; height:4px; background: radial-gradient(circle,#ffd27f 0%,rgba(255,140,0,0) 70%); border-radius:50%; animation: rise 2.2s linear infinite; pointer-events:none; }
@keyframes rise { from { transform: translateY(0) scale(1); opacity:1; } to { transform: translateY(-40px) scale(0); opacity:0; } }
.flame-btn .embers span:nth-child(2){ left:55%; animation-delay:.4s; }
.flame-btn .embers span:nth-child(3){ left:70%; animation-delay:.8s; }
.flame-btn .embers span:nth-child(4){ left:40%; animation-delay:1.2s; }
.flame-btn .embers span:nth-child(5){ left:85%; animation-delay:1.6s; }
.flame-btn:not(.active) .embers { display:none; }

/* Graph container */
#network-visualization { width:100%; height: 750px; border:2px inset var(--bg-color); background: #000; position:relative; }
@media (max-width: 600px) { #network-visualization { height: 600px; } }

/* Legend & Stats */
.legend-list, .stats-list { list-style:none; padding:0; margin:0; font-size:12px; }
.legend-item { display:flex; align-items:center; gap:6px; margin-bottom:6px; }
.legend-color { width:14px; height:14px; border-radius:50%; border:1px solid #000; }
.legend-line { width:28px; height:0; border-top:3px solid #666; display:inline-block; }
.legend-line.dashed { border-top-style:dashed; }
.legend-line.similarity { border-color:#38B2AC; }
.legend-line.prediction { border-color:#FFD700; }
.legend-line.user-genre { border-color:#6B46C1; }
.legend-line.user-country { border-color:#2F855A; }
.legend-line.actor-aff { border-color:#B794F4; }
.legend-line.director-aff { border-color:#D69E2E; }
.stats-list li { display:flex; justify-content:space-between; border-bottom:1px solid var(--border-dark); padding:2px 0; }
.stats-list li:last-child { border-bottom:none; }

/* Tooltip */
.node-tooltip { position:absolute; background: var(--window-bg); border:1px solid var(--border-dark); padding:6px 8px; font-size:11px; pointer-events:none; z-index:1000; max-width:200px; box-shadow:2px 2px 4px var(--shadow-color); }

/* Loading & Error */
.center-box { display:flex; justify-content:center; align-items:center; padding:30px; font-size:13px; color: var(--text-muted); }
.error { color:#a40000; font-weight:bold; }

/* Filter toggle visual states */
.filter-pill label, .ng-filter-label { cursor:pointer; user-select:none; }
.ng-filter-label { padding:3px 6px; border:1px solid var(--border-dark); background:linear-gradient(#e8e8e8,#c8c8c8); border-radius:3px; box-shadow:1px 1px 0 var(--border-light) inset, -1px -1px 0 var(--border-dark) inset; }
@media (prefers-color-scheme: dark){ .ng-filter-label { background:linear-gradient(#585858,#404040); } }
.ng-filter-label.active { font-weight:bold; color:#000; background:linear-gradient(#ffffff,#dcdcdc); }
@media (prefers-color-scheme: dark){ .ng-filter-label.active { color:#fff; background:linear-gradient(#666,#505050);} }
.ng-filter-label.inactive { opacity:0.55; text-decoration:line-through; }
/* Extra emphasis for disabled directors filter */
.ng-filter-label[data-target=directors].inactive { background:repeating-linear-gradient(45deg,#5a2d00,#5a2d00 6px,#7a3b00 6px,#7a3b00 12px); color:#fff; border-color:#2e1500; }
@media (prefers-color-scheme: dark){ .ng-filter-label[data-target=directors].inactive { background:repeating-linear-gradient(45deg,#402200,#402200 6px,#5a2d00 6px,#5a2d00 12px); } }
.legend-item.disabled { opacity:0.28; filter:grayscale(80%); }
.legend-edge-sample { width:18px; height:0; border-top:2px dashed #38B2AC; display:inline-block; }

</style>

<div class="network-page-container">
	<div class="window panel">
		<div class="title-bar">
			<div>Movie Network Graph</div>
			<div class="title-bar-controls">
				<button aria-label="Minimize">_</button>
				<button aria-label="Maximize">□</button>
				<button aria-label="Close">×</button>
			</div>
		</div>
		<div class="window-body">
			<p class="muted" style="line-height:1.3;">Interactive map of <strong>users</strong>, <strong>movies</strong>, and their <strong>genres / countries / talent</strong>. Hubs pull connected items; dashed lines show similarity & affinity strengths.</p>
			<div class="control-grid" style="margin-top:10px;">
				<div class="control-item">
					<label for="min-reviews">Min Reviews</label>
					<input type="number" id="min-reviews" value="1" min="1" max="20">
				</div>
				<div class="control-item">
					<label for="rating-threshold">Rating ≥</label>
					<input type="number" id="rating-threshold" value="5.0" min="1" max="10" step="0.5">
				</div>
				<div class="control-item">
					<label for="max-nodes">Max Nodes</label>
					<input type="number" id="max-nodes" value="150" min="30" max="400" step="10">
				</div>
				<div class="control-item">
					<label for="movie-limit">Movies</label>
					<input type="number" id="movie-limit" value="75" min="5" max="300" step="5">
				</div>
				<div class="control-item">
					<label for="predictions-limit">Predictions</label>
					<input type="number" id="predictions-limit" value="0" min="0" max="100" step="5">
				</div>
				<div class="control-item">
					<label for="layout-type">Layout</label>
					<select id="layout-type" title="Enhanced layout reduces center clustering and spreads nodes more evenly">
						<option value="enhanced" selected>Enhanced (Anti-Cluster)</option>
						<option value="forceAtlas2Based">Force Atlas</option>
						<option value="hierarchical">Hierarchical</option>
						<option value="physics">Physics</option>
					</select>
				</div>
				<div class="control-item" style="align-self:end;">
					<button id="refresh-graph" class="retro-btn" style="width:100%;">Refresh</button>
				</div>
				<div class="control-item" style="align-self:end;">
					<button id="toggle-physics" class="retro-btn" style="width:100%;">Pause Physics</button>
				</div>
				<div class="control-item" style="align-self:end;">
					<button type="button" id="chaos-mode-btn" class="flame-btn" aria-pressed="false" title="Toggle Chaos Mode (adds actors & crew)">Chaos<br>Mode
						<span class="embers" aria-hidden="true">
							<span></span><span></span><span></span><span></span><span></span>
						</span>
					</button>
				</div>
				<div class="control-item" style="grid-column:1/-1; border-top:1px solid var(--border-dark); padding-top:6px;">
					<label style="font-weight:bold; font-size:11px;">Show Node Types:</label>
					<div id="node-filter-pills" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; font-size:11px;">
						<label class="ng-filter-label active" data-target="users"><input type="checkbox" class="ng-filter" data-param="users" checked hidden><span class="filter-text">Users</span></label>
						<label class="ng-filter-label active" data-target="movies"><input type="checkbox" class="ng-filter" data-param="movies" checked hidden><span class="filter-text">Movies</span></label>
						<label class="ng-filter-label active" data-target="countries"><input type="checkbox" class="ng-filter" data-param="countries" checked hidden><span class="filter-text">Countries</span></label>
						<label class="ng-filter-label active" data-target="genres"><input type="checkbox" class="ng-filter" data-param="genres" checked hidden><span class="filter-text">Genres</span></label>
						<label class="ng-filter-label active" data-target="directors"><input type="checkbox" class="ng-filter" data-param="directors" checked hidden><span class="filter-text">Directors</span></label>
						<label class="ng-filter-label active chaos-only" data-target="actors" style="display:none;"><input type="checkbox" class="ng-filter" data-param="actors" checked hidden><span class="filter-text">Actors</span></label>
						<label class="ng-filter-label active chaos-only" data-target="crew" style="display:none;"><input type="checkbox" class="ng-filter" data-param="crew" checked hidden><span class="filter-text">Crew</span></label>
					</div>
				</div>
				<div class="control-item" style="grid-column:1/-1; border-top:1px solid var(--border-dark); padding-top:6px; margin-top:6px;">
					<label style="font-weight:bold; font-size:11px;">Show Edge Types:</label>
					<div id="edge-filter-pills" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; font-size:11px;">
						<label class="ng-filter-label active" data-target="reviews"><input type="checkbox" class="ng-filter" data-param="reviews" checked hidden><span class="filter-text">Reviews</span></label>
						<label class="ng-filter-label active" data-target="similarity"><input type="checkbox" class="ng-filter" data-param="similarity" checked hidden><span class="filter-text">Similarity</span></label>
						<label class="ng-filter-label active" data-target="predictions"><input type="checkbox" class="ng-filter" data-param="predictions" checked hidden><span class="filter-text">Predictions</span></label>
						<label class="ng-filter-label active" data-target="relationships"><input type="checkbox" class="ng-filter" data-param="relationships" checked hidden><span class="filter-text">Relationships</span></label>
						<label class="ng-filter-label active" data-target="affinity"><input type="checkbox" class="ng-filter" data-param="affinity" checked hidden><span class="filter-text">Affinity</span></label>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="graph-layout">
		<div class="left-column">
			<div class="window panel">
				<div class="title-bar"><div>Legend</div><div class="title-bar-controls"></div></div>
				<div class="window-body">
					<ul class="legend-list">
						<li class="legend-item"><span class="legend-color" style="background:#4299E1"></span> Users</li>
						<li class="legend-item"><span class="legend-color" style="background:#F56565"></span> Movies</li>
						<li class="legend-item"><span class="legend-color" style="background:#48BB78"></span> Countries</li>
						<li class="legend-item"><span class="legend-color" style="background:#9F7AEA"></span> Genres</li>
						<li class="legend-item"><span class="legend-color" style="background:#ED8936"></span> Directors</li>
						<li class="legend-item"><span class="legend-color" style="background:#FFD700"></span> Predicted Movie</li>
						<li class="legend-item"><span class="legend-line prediction"></span> Prediction Edge</li>
						<li class="legend-item"><span class="legend-line similarity dashed"></span> Similar Users</li>
						<li class="legend-item"><span class="legend-line user-genre dashed"></span> User→Genre Affinity</li>
						<li class="legend-item"><span class="legend-line user-country dashed"></span> User→Country Affinity</li>
						<li class="legend-item"><span class="legend-line actor-aff dashed"></span> Actor Affinity</li>
						<li class="legend-item"><span class="legend-line director-aff dashed"></span> Director Affinity</li>
						<li class="legend-item chaos-only" style="display:none;"><span class="legend-color" style="background:#FFD700"></span> Actors</li>
						<li class="legend-item chaos-only" style="display:none;"><span class="legend-color" style="background:#00CED1"></span> Crew</li>
					</ul>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar"><div>Graph Stats</div><div class="title-bar-controls"></div></div>
				<div class="window-body">
					<ul id="stats-list" class="stats-list"><li><span>Loading...</span><span></span></li></ul>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar"><div>Analytics</div><div class="title-bar-controls"></div></div>
				<div class="window-body">
					<ul id="analytics-list" class="stats-list">
						<li><span>Communities:</span><span id="totalCommunities">0</span></li>
						<li><span>Modularity:</span><span id="modularity">0.00</span></li>
						<li><span>Avg Centrality:</span><span id="avgCentrality">0.00</span></li>
					</ul>
					<div style="margin-top:8px; font-size:11px;">
						<label style="display:block; margin-bottom:4px;">
							<input type="checkbox" id="showCommunities">
							Color by Community
						</label>
						<label style="display:block;">
							<input type="checkbox" id="showCentrality">
							Size by Centrality
						</label>
					</div>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar"><div>Tips</div><div class="title-bar-controls"></div></div>
				<div class="window-body" style="font-size:12px;">
					<ul style="padding-left:18px; margin:0;">
						<li>Hover nodes for details</li>
						<li>Drag to reposition</li>
						<li>Scroll to zoom</li>
						<li>Click a movie to open its page</li>
						<li>Dashed edges connect similar users</li>
					</ul>
				</div>
			</div>
		</div>
		<div class="right-column">
			<div class="window" style="height:100%;">
				<div class="title-bar"><div>Visualization</div><div class="title-bar-controls"></div></div>
				<div class="window-body" style="padding:8px;">
					<div id="network-visualization"></div>
					<div id="predictions-panel" style="margin-top:6px; font-size:11px; display:none;">
						<strong>Top Predictions</strong>
						<ol id="predictions-list" style="padding-left:18px; margin:4px 0 0 0; max-height:140px; overflow:auto; line-height:1.25;"></ol>
					</div>
					<div id="loading" class="center-box" style="display:none;">Loading network data...</div>
					<div id="error-message" class="center-box error" style="display:none;"></div>
				</div>
			</div>
		</div>
	</div>
</div>

<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script src="{% static 'js/graph-layout-config.js' %}"></script>
<script>
let network = null; let currentData = {nodes:[], edges:[]}; let physicsUserEnabled = true; // tracks manual toggling
let chaosModeEnabled = false; // new state
let autoFreezeTimer = null; // timer to auto-stop spinning

function initNetwork(){
	const container = document.getElementById('network-visualization');
	
	// Get enhanced layout configuration
	const baseOptions = {
		nodes:{ 
			borderWidth:2, 
			shape:'dot', 
			font:{ color:'#fff', size:12, strokeWidth:2, strokeColor:'#000'},
			chosen: false  // Disable selection highlighting for performance
		},
		edges:{ 
			smooth:{ type:'continuous', forceDirection:'none', roundness:0.1}, 
			shadow:false,  // Disable shadows for performance
			width: 1,  // Thinner edges for performance
			selectionWidth: 1  // Disable edge selection width changes
		},
		interaction:{ 
			hover:true, 
			tooltipDelay:200,  // Slightly longer delay to reduce tooltip spam
			hideEdgesOnDrag: true,  // Hide edges while dragging for performance
			hideNodesOnDrag: false
		}
	};
	
	// Enhanced physics configuration to reduce center clustering
	const enhancedPhysics = {
		enabled: true,
		stabilization: {
			enabled: true,
			iterations: 800,
			updateInterval: 25,
			onlyDynamicEdges: false,
			fit: true
		},
		forceAtlas2Based: {
			theta: 0.5,
			gravitationalConstant: -50,
			centralGravity: 0.005,  // Reduced central gravity to spread nodes
			springConstant: 0.18,
			springLength: 120,      // Longer springs to reduce clustering
			damping: 0.4,
			avoidOverlap: 0.5       // Increased overlap avoidance
		},
		maxVelocity: 30,
		minVelocity: 0.1,
		solver: 'forceAtlas2Based',
		timestep: 0.35,
		adaptiveTimestep: true
	};
	
	const options = {
		...baseOptions,
		layout: {
			improvedLayout: true,
			clusterThreshold: 150,
			randomSeed: 42
		},
		physics: enhancedPhysics,
		configure: {
			enabled: false
		}
	};
	
	network = new vis.Network(container, {nodes:[], edges:[]}, options);
	// After stabilization, freeze unless user explicitly wants continuous physics or selected 'physics' layout
	network.once('stabilizationIterationsDone', ()=>{
		if(document.getElementById('layout-type').value !== 'physics' && physicsUserEnabled){
			// Keep userEnabled flag true but pause motion for resting state
			network.setOptions({ physics:false });
			document.getElementById('toggle-physics').textContent = 'Resume Physics';
		}
	});
	network.on('hoverNode', showNodeTooltip);
	network.on('blurNode', hideNodeTooltip);
	network.on('click', params=>{ if(params.nodes.length){ handleNodeClick(params.nodes[0]); }});
}

async function loadGraph(){
	const loading=document.getElementById('loading'); const err=document.getElementById('error-message');
	loading.style.display='flex'; err.style.display='none';
	
	// Clear tooltip cache on new data load
	tooltipCache.clear();
	
	try {
		const qs = new URLSearchParams({ 
			min_reviews: document.getElementById('min-reviews').value, 
			rating_threshold: document.getElementById('rating-threshold').value, 
			max_nodes: document.getElementById('max-nodes').value, 
			predictions_limit: document.getElementById('predictions-limit').value, 
			movie_limit: document.getElementById('movie-limit').value,
			layout_strategy: 'enhanced'  // Always use enhanced backend layout
		});
		if(chaosModeEnabled){ qs.append('chaos','1'); }
		// add filter params
		document.querySelectorAll('.ng-filter').forEach(cb=>{ qs.append(cb.dataset.param, cb.checked ? '1':'0'); });
		
		const loadStart = performance.now();
		const res = await fetch(`/movies/network-graph/data/?${qs.toString()}`);
		if(!res.ok) throw new Error('HTTP '+res.status);
		const data = await res.json(); 
		const loadTime = performance.now() - loadStart;
		
		console.log(`Data loaded in ${loadTime.toFixed(1)}ms - ${data.nodes?.length || 0} nodes, ${data.edges?.length || 0} edges`);
		
		currentData = data; 
		updateNetwork(); 
		updateStats(data.stats);
	} catch(e){ console.error(e); err.textContent='Failed to load graph: '+e.message; err.style.display='flex'; }
	finally { loading.style.display='none'; }
}

function clearAutoFreeze(){ if(autoFreezeTimer){ clearTimeout(autoFreezeTimer); autoFreezeTimer=null; } }

function scheduleAutoFreeze(delay=6000){
	clearAutoFreeze();
	// Automatically pause physics after a delay to prevent endless spinning
	autoFreezeTimer = setTimeout(()=>{
		if(!network) return;
		if(document.getElementById('layout-type').value === 'physics' && physicsUserEnabled){
			network.setOptions({ physics:false });
			const btn = document.getElementById('toggle-physics'); if(btn) btn.textContent='Resume Physics';
		}
	}, delay);
}

function updateNetwork(){
	if(!network) return;
	const layout = document.getElementById('layout-type').value;
	
	// Use enhanced layout configuration function
	const enhancedGraphData = {
		nodes: currentData.nodes || [],
		edges: currentData.edges || []
	};
	
	let opt = {};
	
	if(layout === 'hierarchical') {
		opt = { 
			layout: { 
				hierarchical: { 
					direction: 'UD', 
					levelSeparation: 150, 
					nodeSpacing: 160,
					blockShifting: true,
					edgeMinimization: true,
					parentCentralization: true
				}
			}, 
			physics: false 
		};
	} else if(layout === 'enhanced') {
		// Enhanced anti-clustering layout - our new default
		const nodeCount = enhancedGraphData.nodes.length;
		const edgeCount = enhancedGraphData.edges.length;
		const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;
		
		// Use forceAtlas2Based with enhanced parameters for better spreading
		opt = { 
			physics: { 
				enabled: true,
				solver: 'forceAtlas2Based',
				forceAtlas2Based: {
					theta: 0.5,
					gravitationalConstant: Math.min(-50, -50 - (density * 200)), // Stronger repulsion for dense graphs
					centralGravity: Math.max(0.001, 0.005 - (density * 0.02)), // Much less central pull
					springLength: Math.max(120, 120 + (density * 150)), // Longer springs for denser graphs
					springConstant: Math.max(0.05, 0.18 - (density * 0.1)), // Weaker springs for dense graphs
					damping: 0.4,
					avoidOverlap: Math.min(0.9, 0.5 + (density * 0.4)) // Scale overlap avoidance
				},
				stabilization: { 
					iterations: Math.min(1200, nodeCount * 4), // More iterations for better results
					updateInterval: 25
				}, 
				minVelocity: 0.1,
				maxVelocity: 25, // Slightly lower max velocity for stability
				timestep: 0.35,
				adaptiveTimestep: true
			}
		};
		
		// Additional tweaks for hub nodes
		if(currentData.stats && currentData.stats.hub_user) {
			opt.physics.forceAtlas2Based.gravitationalConstant *= 1.5;
			opt.physics.forceAtlas2Based.centralGravity *= 0.3;
			opt.physics.forceAtlas2Based.springLength *= 1.3;
		}
	} else if(layout === 'forceAtlas2Based') {
		// Use enhanced forceAtlas2Based configuration
		const nodeCount = enhancedGraphData.nodes.length;
		const edgeCount = enhancedGraphData.edges.length;
		const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;
		
		opt = { 
			physics: { 
				enabled: true,
				solver: 'forceAtlas2Based',
				forceAtlas2Based: {
					theta: 0.5,
					gravitationalConstant: -50 - (density * 100), // Scale with density
					centralGravity: Math.max(0.001, 0.005 - (density * 0.01)), // Reduce for dense graphs
					springLength: 120 + (density * 80), // Longer springs for denser graphs
					springConstant: 0.18,
					damping: 0.4,
					avoidOverlap: Math.min(0.8, 0.5 + (density * 0.3)) // More overlap avoidance for dense graphs
				},
				stabilization: { 
					iterations: Math.min(1000, nodeCount * 3),
					updateInterval: 25
				}, 
				minVelocity: 0.1,
				maxVelocity: 30,
				timestep: 0.35,
				adaptiveTimestep: true
			}
		};
	} else {
		// Enhanced default physics with anti-clustering improvements
		const nodeCount = enhancedGraphData.nodes.length;
		const edgeCount = enhancedGraphData.edges.length;
		const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;
		
		// Base configuration optimized for spreading
		let base = { 
			gravitationalConstant: -80 - (density * 150), // Stronger repulsion for dense graphs
			centralGravity: Math.max(0.001, 0.01 - (density * 0.02)), // Less central pull
			springLength: 140 + (density * 100), // Longer springs
			springConstant: Math.max(0.01, 0.04 - (density * 0.02)), // Weaker springs
			damping: 0.4,
			avoidOverlap: Math.min(0.8, 0.3 + (density * 0.4)) // Scale overlap avoidance
		};
		
		// Adjust for hub users (high-degree nodes)
		if(currentData.stats && currentData.stats.hub_user) {
			base.gravitationalConstant *= 1.5; // Even stronger repulsion
			base.centralGravity *= 0.5; // Much less central gravity
			base.springLength *= 1.2; // Longer springs
			base.avoidOverlap = Math.min(0.9, base.avoidOverlap * 1.3);
		}
		
		opt = { 
			physics: { 
				enabled: true,
				solver: 'barnesHut',
				barnesHut: base,
				stabilization: { 
					iterations: Math.min(800, nodeCount * 2),
					updateInterval: 25
				}, 
				minVelocity: 0.1,
				maxVelocity: 30,
				timestep: 0.35,
				adaptiveTimestep: true
			}
		};
	}
	
	network.setOptions(opt);
	
	// Apply client-side filtering
	const filteredData = filterGraphData(currentData);
	
	// Get analytics control states
	const showCommunities = document.getElementById('showCommunities')?.checked ?? false;
	const showCentrality = document.getElementById('showCentrality')?.checked ?? false;
	
	// Community colors (predefined palette)
	const communityColors = [
		'#4299E1', '#F56565', '#48BB78', '#9F7AEA', '#ED8936', '#FFD700',
		'#00CED1', '#FF69B4', '#32CD32', '#FF6347', '#DA70D6', '#20B2AA',
		'#FF4500', '#1E90FF', '#228B22', '#DC143C', '#8A2BE2', '#FF1493'
	];
	
	// Optimize node styling - batch process for performance
	const nodeCount = filteredData.nodes.length;
	const isLargeGraph = nodeCount > 100;
	
	// Debug: Log node type distribution and sizes
	const nodeTypesSizes = {};
	filteredData.nodes.forEach(n => {
		if (!nodeTypesSizes[n.type]) {
			nodeTypesSizes[n.type] = [];
		}
		nodeTypesSizes[n.type].push(n.size);
	});
	console.log('Node type size distribution:', nodeTypesSizes);
	
	// style nodes & edges for clarity
	const styledNodes = filteredData.nodes.map(n=>{ 
		const m = {
			id: n.id,
			label: isLargeGraph && n.label?.length > 15 ? n.label.substring(0, 12) + '...' : n.label,
			group: n.group,
			type: n.type,
			size: n.size || 15  // Preserve original size from backend
		}; 
		
		// Apply backend layout properties for enhanced positioning
		if(n.mass !== undefined) m.mass = n.mass;
		if(n.fixed !== undefined) m.fixed = n.fixed;
		if(n.fx !== undefined) m.x = n.fx;
		if(n.fy !== undefined) m.y = n.fy;
		if(n.x !== undefined && n.fx === undefined) m.x = n.x;
		if(n.y !== undefined && n.fy === undefined) m.y = n.y;
		
		// Apply physics properties for repulsion forces
		if(n.charge !== undefined) {
			// vis.js doesn't have direct charge, but we can use mass to simulate
			m.mass = Math.max(1, Math.abs(n.charge) / 30);
		}
		
		// Apply degree-based spacing for high-connectivity nodes
		if(n.degree !== undefined && n.degree > 10) {
			// Increase mass for high-degree nodes to create natural spacing
			m.mass = Math.max(m.mass || 1, 1 + (n.degree * 0.1));
		}
		
	// Debug: Log different node types to check sizes
		if (filteredData.nodes.indexOf(n) < 10) {
			console.log(`Node ${n.label} (${n.type}): backend size=${n.size}, final size=${m.size}, id=${n.id}, mass=${m.mass}, fixed=${m.fixed}`);
		}
		
		// Preserve original node colors first (optimized)
		if(n.color) {
			m.color = typeof n.color === 'string' ? 
				{ background: n.color, border: '#222' } : 
				{...n.color};
		}
		
		// Special styling for predicted nodes
		if(n.predicted_score){ 
			m.color = { background: m.color?.background || '#F56565', border:'#FFD700'}; 
			m.borderWidth = 3; 
			m.shape = 'dot'; 
		} else if(n.type==='genre' || n.type==='country'){ 
			m.borderWidth = 2; 
		}
		
		// Apply community coloring if enabled (optimized)
		if(showCommunities && n.community !== undefined) {
			const communityNum = typeof n.community === 'string' ? 
				parseInt(n.community.replace('community_', '')) || 0 : 
				(n.community || 0);
			const communityColor = communityColors[communityNum % communityColors.length];
			if(m.color) {
				m.color.background = communityColor;
			} else {
				m.color = { background: communityColor, border: '#222' };
			}
			m.borderWidth = 2;
		}
		
		// Apply centrality sizing if enabled (this overrides the base size)
		if(showCentrality && n.centrality?.degree !== undefined) {
			const centralityScore = n.centrality.degree;
			const baseSize = n.size || 15;
			const sizeMultiplier = Math.max(0.5, Math.min(2.0, centralityScore * 5));
			m.size = Math.round(baseSize * sizeMultiplier);  // Round for performance
		}
		
		// Copy other essential properties
		if(n.predicted_score) m.predicted_score = n.predicted_score;
		if(n.metadata) m.metadata = n.metadata;
		if(n.centrality) m.centrality = n.centrality;
		if(n.community) m.community = n.community;
		if(n.community_name) m.community_name = n.community_name;
		if(n.community_size) m.community_size = n.community_size;
		
		// Copy tooltip-specific properties
		if(n.review_count !== undefined) m.review_count = n.review_count;
		if(n.rating !== undefined) m.rating = n.rating;
		if(n.year !== undefined) m.year = n.year;
		if(n.movie_count !== undefined) m.movie_count = n.movie_count;
		
		// Copy prediction-related properties
		if(n.content_similarity !== undefined) m.content_similarity = n.content_similarity;
		if(n.blend_w_cf !== undefined) m.blend_w_cf = n.blend_w_cf;
		if(n.predicted_contributors !== undefined) m.predicted_contributors = n.predicted_contributors;
		if(n.predicted_std_err !== undefined) m.predicted_std_err = n.predicted_std_err;
		if(n.predicted_confidence !== undefined) m.predicted_confidence = n.predicted_confidence;
		
		// Copy affinity properties
		if(n.genre_affinity !== undefined) m.genre_affinity = n.genre_affinity;
		if(n.country_affinity !== undefined) m.country_affinity = n.country_affinity;
		if(n.director_affinity !== undefined) m.director_affinity = n.director_affinity;
		if(n.keyword_affinity !== undefined) m.keyword_affinity = n.keyword_affinity;
		if(n.matched_keywords !== undefined) m.matched_keywords = n.matched_keywords;
		
		return m; 
	});
	
	// Optimize edge styling - reduce visual complexity for large graphs
	const styledEdges = filteredData.edges.map(e=>{ 
		const m = {
			from: e.from || e.source,  // Handle both from/to and source/target
			to: e.to || e.target,
			type: e.type
		}; 
		
		// Apply backend-calculated edge lengths for better spacing
		if(e.length !== undefined) {
			m.length = e.length;
		}
		
		// Apply backend strength values for physics simulation
		if(e.strength !== undefined) {
			// vis.js uses spring properties for edge strength
			m.spring = {
				length: m.length || 80,
				constant: e.strength
			};
		}
		
		if(e.type==='prediction'){ 
			m.dashes = false; 
			m.color = { color:'#FFD700' }; 
			m.width = isLargeGraph ? 2 : ((e.width||2)+1);
			// Prediction edges should be longer to reduce clustering
			if(!m.length) m.length = 100;
		} else if(e.type && e.type.includes('affinity')){ 
			m.dashes = !isLargeGraph;  // Remove dashes for large graphs
			if(!isLargeGraph) m.smooth = { enabled:true, type:'dynamic'};
			m.width = Math.min(3, (e.width||2));
			m.color = { color: '#999', opacity: isLargeGraph ? 0.3 : 0.6 };
			// Affinity edges should be longer as specified in backend
			if(!m.length) m.length = e.type.includes('user_genre') ? 150 : 160;
		} else if(e.type==='similarity'){ 
			m.dashes = !isLargeGraph;  // Remove dashes for large graphs
			m.color = { color:'#999', opacity: isLargeGraph ? 0.2 : 0.5 };
			m.width = isLargeGraph ? 1 : 2;
			// Similarity edges should be longer to prevent clustering
			if(!m.length) m.length = 120;
		} else {
			// Default edge styling
			m.color = e.color || { color: '#848484', opacity: isLargeGraph ? 0.4 : 0.7 };
			m.width = isLargeGraph ? 1 : (e.width || 2);
			// Apply default length if not set
			if(!m.length) m.length = 80;
		}
		
		// Copy essential properties
		if(e.weight) m.weight = e.weight;
		if(e.label && !isLargeGraph) m.label = e.label;  // Hide labels for large graphs
		if(e.metadata) m.metadata = e.metadata;  // Preserve metadata for tooltips
		
		return m; 
	});
	// Performance optimization: batch update for large graphs
	const updateStart = performance.now();
	
	// Use batch mode for large graphs
	if(nodeCount > 150) {
		network.setOptions({
			physics: { enabled: false }  // Disable physics during large updates
		});
	}
	
	network.setData({ nodes: styledNodes, edges: styledEdges });
	
	// Re-enable physics after update for large graphs
	if(nodeCount > 150) {
		setTimeout(() => {
			if(layout === 'physics') {
				network.setOptions({
					physics: { 
						enabled: true,
						stabilization: { iterations: Math.max(50, Math.min(100, nodeCount / 2)) }
					}
				});
			}
		}, 100);
	}
	
	const updateTime = performance.now() - updateStart;
	if(updateTime > 100) {
		console.log(`Network update took ${updateTime.toFixed(1)}ms for ${nodeCount} nodes`);
	}
	
	if(layout !== 'physics') network.once('stabilizationIterationsDone', ()=>{ if(layout !== 'physics' && physicsUserEnabled){ network.setOptions({physics:false}); document.getElementById('toggle-physics').textContent='Resume Physics'; }});
	else scheduleAutoFreeze(Math.max(3000, Math.min(8000, nodeCount * 50)));  // Scale freeze delay with graph size
	renderPredictionsList();
}

// Filter graph data based on visibility toggles
function filterGraphData(data) {
    // Get filter states
    const getFilterState = (param) => {
        const checkbox = document.querySelector(`.ng-filter[data-param="${param}"]`);
        return checkbox ? checkbox.checked : true;
    };
    
    const showUsers = getFilterState('users');
    const showMovies = getFilterState('movies');
    const showCountries = getFilterState('countries');
    const showGenres = getFilterState('genres');
    const showDirectors = getFilterState('directors');
    const showActors = getFilterState('actors');
    const showCrew = getFilterState('crew');
    
    const showReviews = getFilterState('reviews');
    const showSimilarity = getFilterState('similarity');
    const showPredictions = getFilterState('predictions');
    const showRelationships = getFilterState('relationships');
    const showAffinity = getFilterState('affinity');
    
    // Filter nodes based on type visibility
    const visibleNodeTypes = [];
    if (showUsers) visibleNodeTypes.push('user');
    if (showMovies) visibleNodeTypes.push('movie');
    if (showCountries) visibleNodeTypes.push('country');
    if (showGenres) visibleNodeTypes.push('genre');
    if (showDirectors) visibleNodeTypes.push('director');
    if (showActors) visibleNodeTypes.push('actor');
    if (showCrew) visibleNodeTypes.push('crew');
    
    const filteredNodes = data.nodes.filter(node => visibleNodeTypes.includes(node.type));
    
    // Get IDs of visible nodes for edge filtering
    const visibleNodeIds = new Set(filteredNodes.map(node => node.id));
    
    // Filter edges based on type and connected nodes
    const filteredEdges = data.edges.filter(edge => {
        // Check if both connected nodes are visible
        if (!visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
            return false;
        }
        
        // Check edge type visibility
        const edgeType = edge.type || 'review'; // Default to review if no type specified
        
        // Group edge types for filtering
        if (edgeType === 'review' && !showReviews) return false;
        if (edgeType === 'similarity' && !showSimilarity) return false;
        if (edgeType === 'prediction' && !showPredictions) return false;
        
        // Relationships: movie connections to countries, genres, directors, actors, crew
        const relationshipTypes = ['origin', 'genre', 'directed_by', 'acted_in', 'crew'];
        if (relationshipTypes.includes(edgeType) && !showRelationships) return false;
        
        // Affinity: all dashed affinity edges
        const affinityTypes = ['user_genre_affinity', 'user_country_affinity', 'actor_genre_affinity', 
                              'actor_country_affinity', 'director_genre_affinity', 'director_country_affinity'];
        if (affinityTypes.includes(edgeType) && !showAffinity) return false;
        
        return true;
    });
    
    return {
        nodes: filteredNodes,
        edges: filteredEdges,
        stats: data.stats // Keep original stats for display
    };
}

function renderPredictionsList(){
	const panel=document.getElementById('predictions-panel'); const list=document.getElementById('predictions-list'); if(!panel||!list) return;
	const preds=currentData.nodes.filter(n=> n.predicted_score).sort((a,b)=> b.predicted_score - a.predicted_score).slice(0,25);
	if(!preds.length){ panel.style.display='none'; list.innerHTML=''; return; }
	panel.style.display='block';
	list.innerHTML=preds.map(p=>`<li><span style="color:#FFD700; font-weight:600;">${p.predicted_score}</span> ${p.label} ${p.predicted_confidence? '<span style="opacity:.7;">['+p.predicted_confidence+']</span>':''}</li>`).join('');
}


function updateStats(s){ 
	const list=document.getElementById('stats-list'); 
	if(!s){ list.innerHTML='<li><span>No data</span></li>'; return;} 
	
	// Get filtered data for accurate visible counts
	const filteredData = currentData ? filterGraphData(currentData) : { nodes: [], edges: [] };
	
	// Count visible nodes by type
	const nodeCounts = {};
	filteredData.nodes.forEach(node => {
		nodeCounts[node.type] = (nodeCounts[node.type] || 0) + 1;
	});
	
	list.innerHTML=`
		<li><span>Visible Nodes</span><span>${filteredData.nodes.length}</span></li>
		<li><span>Visible Edges</span><span>${filteredData.edges.length}</span></li>
		<li><span>Users</span><span>${nodeCounts.user || 0}</span></li>
		<li><span>Movies</span><span>${nodeCounts.movie || 0}</span></li>
		<li><span>Countries</span><span>${nodeCounts.country || 0}</span></li>
		<li><span>Genres</span><span>${nodeCounts.genre || 0}</span></li>
		<li><span>Directors</span><span>${nodeCounts.director || 0}</span></li>
		<li><span>Pred Edges</span><span>${filteredData.edges.filter(e => e.type === 'prediction').length}</span></li>
		${s.hub_user ? `<li><span>Hub User</span><span>${s.hub_max_reviews} reviews</span></li>`:''}
		<li class="chaos-only" style="display:${chaosModeEnabled && (nodeCounts.actor || 0) > 0 ? 'flex':'none'}; justify-content:space-between;"><span>Actors</span><span>${nodeCounts.actor || 0}</span></li>
		<li class="chaos-only" style="display:${chaosModeEnabled && (nodeCounts.crew || 0) > 0 ? 'flex':'none'}; justify-content:space-between;"><span>Crew</span><span>${nodeCounts.crew || 0}</span></li>
		<li style="border-top: 1px solid var(--border-dark); margin-top: 0.5rem; padding-top: 0.5rem;"><span>Total (All)</span><span>${s.total_nodes}</span></li>`; 
	document.querySelectorAll('.legend-list .chaos-only').forEach(el=>{ el.style.display = chaosModeEnabled ? 'flex':'none'; }); 

	// Update analytics if available
	updateAnalytics(currentData.analytics);
}

function updateAnalytics(analytics) {
	if (!analytics) {
		// Set default values if no analytics
		const totalCommunitiesEl = document.getElementById('totalCommunities');
		const modularityEl = document.getElementById('modularity');
		const avgCentralityEl = document.getElementById('avgCentrality');
		
		if (totalCommunitiesEl) totalCommunitiesEl.textContent = '0';
		if (modularityEl) modularityEl.textContent = '0.000';
		if (avgCentralityEl) avgCentralityEl.textContent = '0.000';
		return;
	}
	
	const totalCommunitiesEl = document.getElementById('totalCommunities');
	const modularityEl = document.getElementById('modularity');
	const avgCentralityEl = document.getElementById('avgCentrality');
	
	// Extract data from nested analytics structure
	const numCommunities = analytics.communities?.stats?.num_communities || 0;
	const modularity = analytics.centrality?.modularity || 0;
	const avgCentrality = analytics.centrality?.avg_centrality || 0;
	
	if (totalCommunitiesEl) totalCommunitiesEl.textContent = numCommunities;
	if (modularityEl) modularityEl.textContent = modularity.toFixed(3);
	if (avgCentralityEl) avgCentralityEl.textContent = avgCentrality.toFixed(3);
}

function refreshFilterVisuals(){
	document.querySelectorAll('.ng-filter-label').forEach(lbl=>{
		const cb = lbl.querySelector('input.ng-filter');
		if(!cb) return;
		lbl.classList.toggle('active', cb.checked);
		lbl.classList.toggle('inactive', !cb.checked);
		const span = lbl.querySelector('.filter-text');
		if(!span) return;
		if(!span.dataset.baseText){ span.dataset.baseText = span.textContent.trim(); }
		if(!cb.checked){
			if(!span.textContent.includes('(hidden)')){ span.textContent = span.dataset.baseText + ' (hidden)'; }
		} else {
			if(span.textContent.trim() !== span.dataset.baseText){ span.textContent = span.dataset.baseText; }
		}
		// legend dimming
		const target = lbl.getAttribute('data-target');
		if(target){
			if(['actors','crew'].includes(target) && !chaosModeEnabled){
				return; // hidden already
			}
			let selectorMatch = '';
			if(target==='countries') selectorMatch = 'Countries';
			else if(target==='genres') selectorMatch = 'Genres';
			else if(target==='directors') selectorMatch = 'Directors';
			else if(target==='predictions') selectorMatch = 'Predictions';
			else if(target==='similarity') selectorMatch = 'Similar Users';
			else if(target==='actors') selectorMatch = 'Actors';
			else if(target==='crew') selectorMatch = 'Crew';
			if(selectorMatch){
				const legendItems = Array.from(document.querySelectorAll('.legend-list .legend-item'));
				const item = legendItems.find(li=> li.textContent.trim() === selectorMatch);
				if(item){ item.classList.toggle('disabled', !cb.checked); }
			}
		}
	});
}

let tooltipCache = new Map();  // Cache tooltips to reduce computation
let tooltipTimeout = null;  // Debounce tooltip updates

function showNodeTooltip(params){
	const id=params.node; 
	
	// Clear any pending tooltip
	if(tooltipTimeout) {
		clearTimeout(tooltipTimeout);
	}
	
	// Use cached tooltip if available
	if(tooltipCache.has(id)) {
		displayTooltip(tooltipCache.get(id));
		return;
	}
	
	// Debounce tooltip creation for performance
	tooltipTimeout = setTimeout(() => {
		const node=currentData.nodes.find(n=>n.id===id); 
		if(!node) return;
		
		const tooltipHtml = generateTooltipHtml(node);
		tooltipCache.set(id, tooltipHtml);
		displayTooltip(tooltipHtml);
	}, 50);
}

function generateTooltipHtml(node) {
	let lines=[]; const header=`<strong>${node.label}</strong>`;
	if(node.type==='user'){
		lines.push('User'); lines.push('Reviews: '+(node.review_count||0));
	} else if(node.type==='movie') {
		lines.push('Movie');
		lines.push('Rating: '+(node.rating!==undefined? node.rating+'/10':'?'));
		if(node.year) lines.push('Year: '+node.year);
		if(node.predicted_score){
			lines.push(`<span style="color:#FFD700;">Pred: ${node.predicted_score}/10</span>`);
			if(node.content_similarity!==undefined) lines.push('Content sim: '+(node.content_similarity*100).toFixed(0)+'%');
			if(node.blend_w_cf!==undefined) lines.push('CF weight: '+(node.blend_w_cf*100).toFixed(0)+'%');
			if(node.predicted_contributors!==undefined) lines.push('Users: '+node.predicted_contributors);
			if(node.predicted_std_err!==undefined) lines.push('Std err: '+node.predicted_std_err);
		}
		if(node.genre_affinity!==undefined) lines.push(`<span style="color:#6B46C1;">Genre: ${(node.genre_affinity*100).toFixed(0)}%</span>`);
		if(node.country_affinity!==undefined) lines.push(`<span style="color:#2F855A;">Country: ${(node.country_affinity*100).toFixed(0)}%</span>`);
		if(node.director_affinity!==undefined) lines.push(`<span style="color:#D69E2E;">Director: ${(node.director_affinity*100).toFixed(0)}%</span>`);
		if(node.keyword_affinity!==undefined) lines.push(`<span style="color:#3182CE;">Keyword: ${(node.keyword_affinity*100).toFixed(0)}%</span>`);
		if(node.matched_keywords) lines.push('KW: '+node.matched_keywords.slice(0,4).join(', '));
	} else if(node.type==='country') { lines.push('Country Hub'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='genre') { lines.push('Genre Hub'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='director') { lines.push('Director'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='actor') { lines.push('Actor'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='crew') { lines.push('Crew'); lines.push('Movies: '+node.movie_count); }
	
	// Add analytics information (optimized)
	if(node.community !== undefined) {
		const communityName = node.community_name || `Community ${node.community.replace('community_', '')}`;
		lines.push(`<span style="color:#9F7AEA;">Community: ${communityName}</span>`);
		if(node.community_size !== undefined) {
			lines.push(`<span style="color:#9F7AEA;">Comm. Size: ${node.community_size}</span>`);
		}
	}
	if(node.centrality) {
		lines.push('<span style="color:#48BB78; font-weight:bold;">Centrality:</span>');
		if(node.centrality.degree !== undefined) lines.push(`Degree: ${node.centrality.degree.toFixed(3)}`);
		// Limit centrality display for performance
		if(lines.length < 12) {  // Don't show all centrality measures if tooltip is getting too long
			if(node.centrality.betweenness !== undefined) lines.push(`Betweenness: ${node.centrality.betweenness.toFixed(3)}`);
			if(node.centrality.closeness !== undefined) lines.push(`Closeness: ${node.centrality.closeness.toFixed(3)}`);
		}
	}
	
	return header+'<br>'+lines.join('<br>');
}

function displayTooltip(html) {
	hideNodeTooltip();  // Remove existing tooltip
	const t=document.createElement('div'); 
	t.id='node-tooltip'; 
	t.className='node-tooltip'; 
	t.innerHTML=html; 
	document.body.appendChild(t); 
	document.addEventListener('mousemove', positionTooltip);
}

function hideNodeTooltip(){ 
	if(tooltipTimeout) {
		clearTimeout(tooltipTimeout);
		tooltipTimeout = null;
	}
	const t=document.getElementById('node-tooltip'); 
	if(t){ 
		t.remove(); 
		document.removeEventListener('mousemove', positionTooltip);
	} 
}
function positionTooltip(e){ const t=document.getElementById('node-tooltip'); if(t){ t.style.left=(e.pageX+12)+'px'; t.style.top=(e.pageY+12)+'px'; } }
function handleNodeClick(id){
	const node=currentData.nodes.find(n=>n.id===id);
	if(!node) return;
	if(node.type==='movie'){
		const tmdb = node.tmdb_id;
		if(tmdb){
			window.open(`/movies/${tmdb}/`, '_blank');
		}
	}
}

document.getElementById('refresh-graph').addEventListener('click', loadGraph);
const chaosBtn = document.getElementById('chaos-mode-btn');
chaosBtn.addEventListener('click', ()=>{
	chaosModeEnabled = !chaosModeEnabled;
	chaosBtn.classList.toggle('active', chaosModeEnabled);
	chaosBtn.setAttribute('aria-pressed', chaosModeEnabled ? 'true':'false');
	if(chaosModeEnabled){ chaosBtn.title='Chaos Mode ON'; } else { chaosBtn.title='Chaos Mode OFF'; }
	document.querySelectorAll('.chaos-only').forEach(el=>{ el.style.display = chaosModeEnabled ? 'flex':'none'; });
	refreshFilterVisuals();
	loadGraph();
});
document.getElementById('layout-type').addEventListener('change', ()=> { if(currentData.nodes.length){ updateNetwork(); } else { clearAutoFreeze(); } });

// auto refresh on checkbox change (debounced)
let filterChangeTimer=null;
document.querySelectorAll('.ng-filter').forEach(cb=>{
	cb.addEventListener('change', ()=>{
		if(filterChangeTimer) clearTimeout(filterChangeTimer);
		refreshFilterVisuals();
		// For client-side filtering, update immediately for node/edge type filters
		const param = cb.dataset.param;
		if(['users', 'movies', 'reviews', 'relationships', 'affinity'].includes(param) && currentData) {
			updateNetwork();
			updateStats(currentData.stats);
		} else {
			// For backend parameters, reload from server
			filterChangeTimer = setTimeout(()=>{ loadGraph(); }, 250);
		}
	});
});

// Analytics controls
document.getElementById('showCommunities')?.addEventListener('change', ()=>{
	if(currentData) updateNetwork();
});
document.getElementById('showCentrality')?.addEventListener('change', ()=>{
	if(currentData) updateNetwork();
});

// initial visual state
refreshFilterVisuals();

// Toggle physics manually
document.getElementById('toggle-physics').addEventListener('click', ()=>{
	if(!network) return;
	const btn = document.getElementById('toggle-physics');
	const current = network.physics.physicsEnabled;
	if(current){
		network.setOptions({physics:false});
		clearAutoFreeze();
		btn.textContent='Resume Physics';
	} else {
		network.setOptions({physics:{ enabled:true }});
		network.stabilize();
		scheduleAutoFreeze();
		btn.textContent='Pause Physics';
	}
});


document.addEventListener('DOMContentLoaded', ()=>{ initNetwork(); loadGraph(); });
window.addEventListener('resize', ()=> network && network.redraw());
</script>
{% endblock %}

