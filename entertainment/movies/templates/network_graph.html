{% extends "components/base.html" %}
{% load static %}

{% comment %}
MultiGravity Force Atlas Network Graph

This page displays an interactive network graph using the MultiGravity Force Atlas algorithm.
Unlike traditional Force Atlas which tends to cluster nodes in the center, MultiGravity 
uses different gravitational centers for different node types:

- Users: Top-left quadrant
- Movies: Top-right quadrant  
- Genres: Bottom center
- Countries: Bottom-left
- Directors: Right side
- Actors: Bottom-right
- Crew: Bottom-left

This creates natural separation between node types while maintaining meaningful connections.
The algorithm automatically adjusts repulsion forces, spring lengths, and masses based on
node types and connectivity to prevent hub clustering.
{% endcomment %}

{% block title %}Movie Network Graph{% endblock %}

{% block content %}
<style>
/* Retro theme variables (aligned with other pages) */
:root {
	--bg-color: #c0c0c0;
	--text-color: #000;
	--text-muted: #444;
	--border-dark: #808080;
	--border-light: #dfdfdf;
	--window-bg: #c0c0c0;
	--button-bg: #c0c0c0;
	--button-text: #000;
	--button-hover: #e0e0e0;
	--shadow-color: rgba(0,0,0,0.3);
}

@media (prefers-color-scheme: dark) {
	:root {
		--bg-color: #383838;
		--text-color: #fff;
		--text-muted: #b0b0b0;
		--border-dark: #2a2a2a;
		--border-light: #505050;
		--window-bg: #404040;
		--button-bg: #505050;
		--button-text: #fff;
		--button-hover: #606060;
		--shadow-color: rgba(0,0,0,0.5);
	}
}

.network-page-container { max-width: 1400px; margin: 0 auto; padding: 20px; }

.window { border: 2px outset var(--bg-color); background: var(--window-bg); font-family: 'MS Sans Serif', sans-serif; box-shadow: 2px 2px 4px var(--shadow-color); margin-bottom: 20px; }
.title-bar { background: linear-gradient(90deg, #0f0f81 0%, #1084d0 100%); color:#fff; padding:2px 6px; font-size:11px; font-weight:bold; display:flex; justify-content:space-between; align-items:center; }
@media (prefers-color-scheme: dark) { .title-bar { background: linear-gradient(90deg,#1a1a3a 0%, #2060a0 100%);} }
.title-bar-controls button { width:16px; height:14px; border:1px outset var(--button-bg); background: var(--button-bg); font-size:8px; cursor:pointer; }
.title-bar-controls button:active { border:1px inset var(--button-bg); }
.window-body { padding:12px; color: var(--text-color); background: var(--window-bg); }

.retro-btn { border:1px outset var(--button-bg); background: var(--button-bg); color:var(--button-text); padding:2px 10px; font-size:12px; cursor:pointer; text-decoration:none; display:inline-block; }
.retro-btn:hover { background: var(--button-hover); text-decoration:none; }
.retro-btn:active { border:1px inset var(--button-bg); }

/* Layout */
.graph-layout { display: grid; grid-template-columns: 320px 1fr; gap: 20px; }
@media (max-width: 1100px) { .graph-layout { grid-template-columns: 1fr; } }

.panel { margin-bottom: 20px; }
.panel h3 { margin:0 0 8px 0; font-size:14px; }
.muted { color: var(--text-muted); font-size: 12px; }

/* Controls */
.control-grid { display:grid; grid-template-columns: repeat(auto-fill,minmax(140px,1fr)); gap:10px; }
.control-item { display:flex; flex-direction:column; gap:4px; font-size:11px; }
.control-item input, .control-item select { padding:4px; font-size:12px; border:1px solid var(--border-dark); background: var(--button-bg); color: var(--text-color); }

/* Chaos Mode Button */
.flame-btn {
		position: relative;
		border: 2px outset #b22222;
		background: linear-gradient(180deg,#ff7b00 0%,#ff4500 60%,#8b0000 100%);
		color: #fff;
		font-weight: bold;
		font-size: 12px;
		padding: 6px 10px 6px 30px; /* space for flame icon */
		cursor: pointer;
		text-transform: uppercase;
		letter-spacing: 1px;
		box-shadow: 0 0 6px rgba(255,80,0,0.6), 0 0 12px rgba(255,140,0,0.4);
		overflow: hidden;
		transition: filter .25s, transform .1s, box-shadow .3s;
}
.flame-btn:active { border:2px inset #b22222; transform: translateY(1px); }
.flame-btn:hover { filter: brightness(1.1); box-shadow: 0 0 8px rgba(255,120,0,0.9), 0 0 18px rgba(255,80,0,0.6); }
.flame-btn.active { background: linear-gradient(180deg,#ffe066 0%,#ff8c00 40%,#ff4500 70%,#650000 100%); box-shadow: 0 0 10px 4px rgba(255,160,0,0.8), 0 0 25px rgba(255,50,0,0.7); }

/* Animated flame pseudo */
.flame-btn::before {
	content: '\1F525'; /* single fire emoji */
	position: absolute;
	left: 8px;
	top: 50%;
	transform: translateY(-50%) scale(1);
	animation: flicker 1s infinite ease-in-out;
	filter: drop-shadow(0 0 4px rgba(255,150,0,0.9));
	font-size: 16px;
}

@keyframes flicker {
	0%,100% { transform: translateY(-50%) scale(1) rotate(-2deg); opacity:1; }
	20% { transform: translateY(-48%) scale(1.05) rotate(2deg); }
	40% { transform: translateY(-52%) scale(0.95) rotate(-1deg); opacity:.85; }
	60% { transform: translateY(-49%) scale(1.08) rotate(1deg); }
	80% { transform: translateY(-51%) scale(0.98) rotate(-2deg); opacity:.9; }
}

/* Ember particles */
.flame-btn .embers span { position:absolute; width:4px; height:4px; background: radial-gradient(circle,#ffd27f 0%,rgba(255,140,0,0) 70%); border-radius:50%; animation: rise 2.2s linear infinite; pointer-events:none; }
@keyframes rise { from { transform: translateY(0) scale(1); opacity:1; } to { transform: translateY(-40px) scale(0); opacity:0; } }
.flame-btn .embers span:nth-child(2){ left:55%; animation-delay:.4s; }
.flame-btn .embers span:nth-child(3){ left:70%; animation-delay:.8s; }
.flame-btn .embers span:nth-child(4){ left:40%; animation-delay:1.2s; }
.flame-btn .embers span:nth-child(5){ left:85%; animation-delay:1.6s; }
.flame-btn:not(.active) .embers { display:none; }

/* Graph container */
#network-visualization { width:100%; height: 750px; border:2px inset var(--bg-color); background: #000; position:relative; }
@media (max-width: 600px) { #network-visualization { height: 600px; } }

/* Legend & Stats */
.legend-list, .stats-list { list-style:none; padding:0; margin:0; font-size:12px; }
.legend-item { display:flex; align-items:center; gap:6px; margin-bottom:6px; }
.legend-color { width:14px; height:14px; border-radius:50%; border:1px solid #000; }
.legend-line { width:28px; height:0; border-top:3px solid #666; display:inline-block; }
.legend-line.dashed { border-top-style:dashed; }
.legend-line.similarity { border-color:#38B2AC; }
.legend-line.prediction { border-color:#FFD700; }
.legend-line.user-genre { border-color:#6B46C1; }
.legend-line.user-country { border-color:#2F855A; }
.legend-line.actor-aff { border-color:#B794F4; }
.legend-line.director-aff { border-color:#D69E2E; }
.stats-list li { display:flex; justify-content:space-between; border-bottom:1px solid var(--border-dark); padding:2px 0; }
.stats-list li:last-child { border-bottom:none; }

/* ============================================================================
   ENHANCED ANALYTICS PANEL STYLES
   ============================================================================ */

/* Analytics Sections */
.analytics-section { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-dark); }
.analytics-section:last-child { border-bottom: none; margin-bottom: 0; }

.section-header { 
	display: flex; 
	align-items: center; 
	gap: 6px; 
	margin-bottom: 10px; 
	font-size: 13px;
}
.section-icon { font-size: 16px; }
.help-icon {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background: var(--button-bg);
	border: 1px solid var(--border-dark);
	font-size: 10px;
	cursor: help;
	margin-left: auto;
}

.badge {
	display: inline-block;
	width: 8px;
	height: 8px;
	border-radius: 50%;
	background: #48BB78;
	animation: pulse 2s infinite;
}
@keyframes pulse {
	0%, 100% { opacity: 1; }
	50% { opacity: 0.5; }
}

/* Health Display */
.health-display { text-align: center; }
.health-score-container { margin-bottom: 8px; }
.health-score {
	font-size: 36px;
	font-weight: bold;
	line-height: 1;
	margin-bottom: 4px;
}
.health-score.excellent { color: #48BB78; }
.health-score.good { color: #48BB78; }
.health-score.fair { color: #ED8936; }
.health-score.poor { color: #F56565; }

.health-status {
	font-size: 11px;
	text-transform: uppercase;
	letter-spacing: 0.5px;
	font-weight: bold;
}
.health-status.excellent { color: #48BB78; }
.health-status.good { color: #48BB78; }
.health-status.fair { color: #ED8936; }
.health-status.poor { color: #F56565; }

.health-bar-container {
	width: 100%;
	height: 20px;
	border: 2px inset var(--bg-color);
	background: var(--window-bg);
	position: relative;
	overflow: hidden;
}
.health-bar {
	height: 100%;
	transition: width 0.5s ease, background 0.3s ease;
	background: linear-gradient(90deg, #48BB78 0%, #38A169 100%);
}
.health-bar.excellent { background: linear-gradient(90deg, #48BB78 0%, #38A169 100%); }
.health-bar.good { background: linear-gradient(90deg, #48BB78 0%, #38A169 100%); }
.health-bar.fair { background: linear-gradient(90deg, #ED8936 0%, #DD6B20 100%); }
.health-bar.poor { background: linear-gradient(90deg, #F56565 0%, #E53E3E 100%); }

.health-breakdown { margin-top: 10px; }
.health-metric {
	display: grid;
	grid-template-columns: 80px 1fr 35px;
	align-items: center;
	gap: 6px;
	margin-bottom: 6px;
	font-size: 11px;
}
.metric-label { font-weight: bold; }
.metric-bar-bg {
	height: 12px;
	border: 1px inset var(--bg-color);
	background: var(--window-bg);
	position: relative;
	overflow: hidden;
}
.metric-bar {
	height: 100%;
	background: linear-gradient(90deg, #4299E1 0%, #3182CE 100%);
	transition: width 0.5s ease;
}
.metric-value { text-align: right; font-weight: bold; }

/* Engagement Display */
.engagement-display {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 8px;
	text-align: center;
}
.engagement-stat {
	padding: 8px 4px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
}
.stat-number {
	font-size: 20px;
	font-weight: bold;
	color: #4299E1;
	line-height: 1;
	margin-bottom: 4px;
}
.stat-label {
	font-size: 10px;
	text-transform: uppercase;
	color: var(--text-muted);
}

/* Trend Display */
.trend-display { }
.trend-indicator {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 8px;
	padding: 12px;
	border: 2px solid var(--border-dark);
	background: var(--window-bg);
	margin-bottom: 8px;
}
.trend-icon {
	font-size: 24px;
	animation: trend-pulse 2s infinite;
}
@keyframes trend-pulse {
	0%, 100% { transform: scale(1); }
	50% { transform: scale(1.1); }
}
.trend-text {
	font-size: 14px;
	font-weight: bold;
	text-transform: capitalize;
}
.trend-text.growing { color: #48BB78; }
.trend-text.declining { color: #F56565; }
.trend-text.stable { color: #4299E1; }

.trend-stats {
	display: flex;
	justify-content: space-around;
	font-size: 11px;
}
.trend-stat {
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 2px;
}
.stat-value {
	font-weight: bold;
	color: #4299E1;
}

/* Influencers Section */
.influencers-tabs {
	display: flex;
	gap: 4px;
	margin-bottom: 8px;
}
.tab-btn {
	flex: 1;
	padding: 4px 8px;
	border: 1px outset var(--button-bg);
	background: var(--button-bg);
	color: var(--button-text);
	font-size: 11px;
	cursor: pointer;
	transition: all 0.2s;
}
.tab-btn:hover { background: var(--button-hover); }
.tab-btn:active { border: 1px inset var(--button-bg); }
.tab-btn.active {
	background: var(--window-bg);
	border: 1px inset var(--button-bg);
	font-weight: bold;
}

.influencers-content { }
.influencer-list { max-height: 200px; overflow-y: auto; }
.influencer-card {
	display: flex;
	align-items: center;
	gap: 8px;
	padding: 6px;
	margin-bottom: 4px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
	font-size: 11px;
	cursor: pointer;
	transition: all 0.2s;
}
.influencer-card:hover {
	background: var(--button-hover);
	border-color: var(--border-light);
}
.influencer-rank {
	font-weight: bold;
	font-size: 14px;
	min-width: 20px;
	text-align: center;
}
.influencer-rank.rank-1 { color: #FFD700; }
.influencer-rank.rank-2 { color: #C0C0C0; }
.influencer-rank.rank-3 { color: #CD7F32; }
.influencer-details {
	flex: 1;
	min-width: 0;
}
.influencer-name {
	font-weight: bold;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}
.influencer-meta {
	font-size: 10px;
	color: var(--text-muted);
}
.influencer-score {
	font-weight: bold;
	font-size: 16px;
	color: #4299E1;
	min-width: 35px;
	text-align: right;
}
.influencer-placeholder {
	text-align: center;
	padding: 20px;
	color: var(--text-muted);
	font-size: 11px;
}

/* Quick Stats Grid */
.quick-stats-grid {
	display: grid;
	grid-template-columns: repeat(2, 1fr);
	gap: 8px;
}
.quick-stat {
	padding: 8px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
	text-align: center;
}
.quick-stat-label {
	font-size: 10px;
	color: var(--text-muted);
	margin-bottom: 4px;
}
.quick-stat-value {
	font-size: 16px;
	font-weight: bold;
	color: #4299E1;
}

/* Communities Section */
.community-stats {
	display: flex;
	justify-content: space-between;
	gap: 8px;
	margin-bottom: 8px;
}
.community-stat {
	flex: 1;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 2px;
	font-size: 11px;
}
.community-list {
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
	padding: 4px;
}
.community-item {
	display: flex;
	align-items: center;
	gap: 8px;
	padding: 6px;
	margin-bottom: 4px;
	border: 1px solid var(--border-dark);
	background: rgba(159, 122, 234, 0.1);
	font-size: 11px;
	cursor: pointer;
	transition: all 0.2s;
}
.community-item:hover {
	background: rgba(159, 122, 234, 0.2);
	border-color: #9F7AEA;
}
.community-item:last-child {
	margin-bottom: 0;
}
.community-color {
	width: 16px;
	height: 16px;
	border-radius: 2px;
	border: 1px solid var(--border-dark);
	flex-shrink: 0;
}
.community-info {
	flex: 1;
	min-width: 0;
}
.community-name {
	font-weight: bold;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	margin-bottom: 2px;
}
.community-meta {
	font-size: 10px;
	color: var(--text-muted);
}
.community-size {
	font-weight: bold;
	color: #9F7AEA;
	min-width: 30px;
	text-align: right;
}

/* Button Variants */
.retro-btn-sm {
	font-size: 10px;
	padding: 3px 8px;
}

/* ============================================================================
   NODE DETAIL MODAL STYLES
   ============================================================================ */
.modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 10000;
	display: flex;
	align-items: center;
	justify-content: center;
}

.modal-overlay {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.7);
	backdrop-filter: blur(2px);
}

.modal-window {
	position: relative;
	width: 90%;
	max-width: 600px;
	max-height: 80vh;
	display: flex;
	flex-direction: column;
	animation: modalSlideIn 0.3s ease;
}

@keyframes modalSlideIn {
	from {
		opacity: 0;
		transform: translateY(-20px);
	}
	to {
		opacity: 1;
		transform: translateY(0);
	}
}

.modal-body {
	overflow-y: auto;
	max-height: 60vh;
	padding: 16px;
}

.modal-footer {
	display: flex;
	gap: 8px;
	justify-content: flex-end;
	padding: 12px;
	border-top: 2px inset var(--bg-color);
}

.modal-loading {
	text-align: center;
	padding: 40px 20px;
	color: var(--text-muted);
}

/* Modal Content Sections */
.modal-section {
	margin-bottom: 16px;
	padding-bottom: 12px;
	border-bottom: 1px solid var(--border-dark);
}

.modal-section:last-child {
	border-bottom: none;
	margin-bottom: 0;
}

.modal-section-title {
	font-weight: bold;
	font-size: 13px;
	margin-bottom: 8px;
	display: flex;
	align-items: center;
	gap: 6px;
}

.modal-section-icon {
	font-size: 16px;
}

/* Node Header */
.node-header {
	display: flex;
	align-items: flex-start;
	gap: 12px;
	margin-bottom: 16px;
	padding-bottom: 16px;
	border-bottom: 2px solid var(--border-dark);
}

.node-icon {
	font-size: 48px;
	line-height: 1;
	width: 48px;
	height: 48px;
	display: flex;
	align-items: center;
	justify-content: center;
	flex-shrink: 0;
	border-radius: 50%;
	overflow: hidden;
	background: var(--bg-secondary);
	border: 2px solid var(--border);
}

.node-icon img {
	width: 100%;
	height: 100%;
	object-fit: cover;
}

.node-icon.emoji {
	border: none;
	background: transparent;
}

.node-info {
	flex: 1;
	min-width: 0;
}

.node-name {
	font-size: 18px;
	font-weight: bold;
	margin-bottom: 4px;
}

.node-type {
	font-size: 11px;
	text-transform: uppercase;
	color: var(--text-muted);
	letter-spacing: 0.5px;
	margin-bottom: 8px;
}

.node-meta {
	display: flex;
	flex-wrap: wrap;
	gap: 12px;
	font-size: 12px;
}

.meta-item {
	display: flex;
	flex-direction: column;
	gap: 2px;
}

.meta-label {
	font-size: 10px;
	color: var(--text-muted);
	text-transform: uppercase;
}

.meta-value {
	font-weight: bold;
	color: #4299E1;
}

/* Influence Breakdown */
.influence-grid {
	display: grid;
	grid-template-columns: repeat(2, 1fr);
	gap: 8px;
}

.influence-item {
	padding: 8px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
}

.influence-label {
	font-size: 10px;
	color: var(--text-muted);
	margin-bottom: 4px;
}

.influence-value {
	font-size: 16px;
	font-weight: bold;
	color: #4299E1;
}

.influence-bar-container {
	margin-top: 4px;
	height: 6px;
	border: 1px inset var(--bg-color);
	background: var(--window-bg);
}

.influence-bar {
	height: 100%;
	background: linear-gradient(90deg, #4299E1 0%, #3182CE 100%);
	transition: width 0.5s ease;
}

/* Reviews List */
.reviews-list {
	max-height: 300px;
	overflow-y: auto;
}

.review-item {
	padding: 8px;
	margin-bottom: 8px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
	font-size: 12px;
}

.review-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 4px;
}

.review-rating {
	font-weight: bold;
	color: #FFD700;
}

.review-date {
	font-size: 10px;
	color: var(--text-muted);
}

.review-movie {
	font-weight: bold;
	margin-bottom: 2px;
}

.review-text {
	font-size: 11px;
	color: var(--text-muted);
	font-style: italic;
}

/* Connections List */
.connections-list {
	display: flex;
	flex-wrap: wrap;
	gap: 6px;
}

.connection-badge {
	padding: 4px 8px;
	border: 1px solid var(--border-dark);
	background: var(--button-bg);
	font-size: 11px;
	border-radius: 2px;
	cursor: pointer;
	transition: all 0.2s;
}

.connection-badge:hover {
	background: var(--button-hover);
	border-color: var(--border-light);
}

/* Community Detail (Modal) */
.community-detail {
	padding: 8px;
	border: 1px solid var(--border-dark);
	background: rgba(159, 122, 234, 0.05);
}

.community-detail-header {
	display: flex;
	align-items: center;
	gap: 10px;
	margin-bottom: 12px;
	padding-bottom: 8px;
	border-bottom: 1px solid var(--border-dark);
}

.community-detail-name {
	font-size: 13px;
	font-weight: bold;
	color: #9F7AEA;
}

.community-detail-stats {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 8px;
}

.detail-stat {
	text-align: center;
	padding: 6px;
	border: 1px solid var(--border-dark);
	background: var(--window-bg);
}

.detail-stat-label {
	font-size: 10px;
	color: var(--text-muted);
	margin-bottom: 4px;
}

.detail-stat-value {
	font-size: 14px;
	font-weight: bold;
	color: #9F7AEA;
}

/* Tooltip */
.node-tooltip { position:absolute; background: var(--window-bg); border:1px solid var(--border-dark); padding:6px 8px; font-size:11px; pointer-events:none; z-index:1000; max-width:200px; box-shadow:2px 2px 4px var(--shadow-color); }

/* Loading & Error */
.center-box { display:flex; justify-content:center; align-items:center; padding:30px; font-size:13px; color: var(--text-muted); }
.error { color:#a40000; font-weight:bold; }

/* Filter toggle visual states */
.filter-pill label, .ng-filter-label { cursor:pointer; user-select:none; }
.ng-filter-label { padding:3px 6px; border:1px solid var(--border-dark); background:linear-gradient(#e8e8e8,#c8c8c8); border-radius:3px; box-shadow:1px 1px 0 var(--border-light) inset, -1px -1px 0 var(--border-dark) inset; }
@media (prefers-color-scheme: dark){ .ng-filter-label { background:linear-gradient(#585858,#404040); } }
.ng-filter-label.active { font-weight:bold; color:#000; background:linear-gradient(#ffffff,#dcdcdc); }
@media (prefers-color-scheme: dark){ .ng-filter-label.active { color:#fff; background:linear-gradient(#666,#505050);} }
.ng-filter-label.inactive { opacity:0.55; text-decoration:line-through; }
/* Extra emphasis for disabled directors filter */
.ng-filter-label[data-target=directors].inactive { background:repeating-linear-gradient(45deg,#5a2d00,#5a2d00 6px,#7a3b00 6px,#7a3b00 12px); color:#fff; border-color:#2e1500; }
@media (prefers-color-scheme: dark){ .ng-filter-label[data-target=directors].inactive { background:repeating-linear-gradient(45deg,#402200,#402200 6px,#5a2d00 6px,#5a2d00 12px); } }
.legend-item.disabled { opacity:0.28; filter:grayscale(80%); }
.legend-edge-sample { width:18px; height:0; border-top:2px dashed #38B2AC; display:inline-block; }

</style>

<div class="network-page-container">
	<div class="window panel">
		<div class="title-bar">
			<div>MultiGravity Force Atlas - Movie Network</div>
			<div class="title-bar-controls">
				<button aria-label="Minimize">_</button>
				<button aria-label="Maximize">‚ñ°</button>
				<button aria-label="Close">√ó</button>
			</div>
		</div>
		<div class="window-body">
			<p class="muted" style="line-height:1.3;">Interactive map of <strong>users</strong>, <strong>movies</strong>, and their <strong>genres / countries / talent</strong>. Hubs pull connected items; dashed lines show similarity & affinity strengths.</p>
			<div class="control-grid" style="margin-top:10px;">
				<div class="control-item">
					<label for="min-reviews">Min Reviews</label>
					<input type="number" id="min-reviews" value="1" min="1" max="20">
				</div>
				<div class="control-item">
					<label for="rating-threshold">Rating ‚â•</label>
					<input type="number" id="rating-threshold" value="5.0" min="1" max="10" step="0.5">
				</div>
				<div class="control-item">
					<label for="max-nodes">Max Nodes</label>
					<input type="number" id="max-nodes" value="150" min="30" max="400" step="10">
				</div>
				<div class="control-item">
					<label for="movie-limit">Movies</label>
					<input type="number" id="movie-limit" value="75" min="5" max="300" step="5">
				</div>
				<div class="control-item">
					<label for="predictions-limit">Predictions</label>
					<input type="number" id="predictions-limit" value="0" min="0" max="100" step="5">
				</div>
				<div class="control-item" style="align-self:end;">
					<button id="refresh-graph" class="retro-btn" style="width:100%;">Refresh</button>
				</div>
				<div class="control-item" style="align-self:end;">
					<button type="button" id="chaos-mode-btn" class="flame-btn" aria-pressed="false" title="Toggle Chaos Mode (adds actors & crew)">Chaos<br>Mode
						<span class="embers" aria-hidden="true">
							<span></span><span></span><span></span><span></span><span></span>
						</span>
					</button>
				</div>
				<div class="control-item" style="grid-column:1/-1; border-top:1px solid var(--border-dark); padding-top:6px;">
					<label style="font-weight:bold; font-size:11px;">Show Node Types:</label>
					<div id="node-filter-pills" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; font-size:11px;">
						<label class="ng-filter-label active" data-target="users"><input type="checkbox" class="ng-filter" data-param="users" checked hidden><span class="filter-text">Users</span></label>
						<label class="ng-filter-label active" data-target="movies"><input type="checkbox" class="ng-filter" data-param="movies" checked hidden><span class="filter-text">Movies</span></label>
						<label class="ng-filter-label active" data-target="countries"><input type="checkbox" class="ng-filter" data-param="countries" checked hidden><span class="filter-text">Countries</span></label>
						<label class="ng-filter-label active" data-target="genres"><input type="checkbox" class="ng-filter" data-param="genres" checked hidden><span class="filter-text">Genres</span></label>
						<label class="ng-filter-label active" data-target="directors"><input type="checkbox" class="ng-filter" data-param="directors" checked hidden><span class="filter-text">Directors</span></label>
						<label class="ng-filter-label active chaos-only" data-target="actors" style="display:none;"><input type="checkbox" class="ng-filter" data-param="actors" checked hidden><span class="filter-text">Actors</span></label>
						<label class="ng-filter-label active chaos-only" data-target="crew" style="display:none;"><input type="checkbox" class="ng-filter" data-param="crew" checked hidden><span class="filter-text">Crew</span></label>
					</div>
				</div>
				<div class="control-item" style="grid-column:1/-1; border-top:1px solid var(--border-dark); padding-top:6px; margin-top:6px;">
					<label style="font-weight:bold; font-size:11px;">Show Edge Types:</label>
					<div id="edge-filter-pills" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; font-size:11px;">
						<label class="ng-filter-label active" data-target="reviews"><input type="checkbox" class="ng-filter" data-param="reviews" checked hidden><span class="filter-text">Reviews</span></label>
						<label class="ng-filter-label active" data-target="similarity"><input type="checkbox" class="ng-filter" data-param="similarity" checked hidden><span class="filter-text">Similarity</span></label>
						<label class="ng-filter-label active" data-target="predictions"><input type="checkbox" class="ng-filter" data-param="predictions" checked hidden><span class="filter-text">Predictions</span></label>
						<label class="ng-filter-label active" data-target="relationships"><input type="checkbox" class="ng-filter" data-param="relationships" checked hidden><span class="filter-text">Relationships</span></label>
						<label class="ng-filter-label active" data-target="affinity"><input type="checkbox" class="ng-filter" data-param="affinity" checked hidden><span class="filter-text">Affinity</span></label>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="graph-layout">
		<div class="left-column">
			<div class="window panel">
				<div class="title-bar"><div>Legend</div><div class="title-bar-controls"></div></div>
				<div class="window-body">
					<ul class="legend-list">
						<li class="legend-item"><span class="legend-color" style="background:#4299E1"></span> Users</li>
						<li class="legend-item"><span class="legend-color" style="background:#F56565"></span> Movies</li>
						<li class="legend-item"><span class="legend-color" style="background:#48BB78"></span> Countries</li>
						<li class="legend-item"><span class="legend-color" style="background:#9F7AEA"></span> Genres</li>
						<li class="legend-item"><span class="legend-color" style="background:#ED8936"></span> Directors</li>
						<li class="legend-item"><span class="legend-color" style="background:#FFD700"></span> Predicted Movie</li>
						<li class="legend-item"><span class="legend-line prediction"></span> Prediction Edge</li>
						<li class="legend-item"><span class="legend-line similarity dashed"></span> Similar Users</li>
						<li class="legend-item"><span class="legend-line user-genre dashed"></span> User‚ÜíGenre Affinity</li>
						<li class="legend-item"><span class="legend-line user-country dashed"></span> User‚ÜíCountry Affinity</li>
						<li class="legend-item"><span class="legend-line actor-aff dashed"></span> Actor Affinity</li>
						<li class="legend-item"><span class="legend-line director-aff dashed"></span> Director Affinity</li>
						<li class="legend-item chaos-only" style="display:none;"><span class="legend-color" style="background:#FFD700"></span> Actors</li>
						<li class="legend-item chaos-only" style="display:none;"><span class="legend-color" style="background:#00CED1"></span> Crew</li>
					</ul>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar"><div>Graph Stats</div><div class="title-bar-controls"></div></div>
				<div class="window-body">
					<ul id="stats-list" class="stats-list"><li><span>Loading...</span><span></span></li></ul>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar">
					<div>Analytics <span id="analytics-badge" class="badge" style="display:none;">‚óè</span></div>
					<div class="title-bar-controls"></div>
				</div>
				<div class="window-body" style="padding:10px;">
					<!-- Network Health Section -->
					<div id="health-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">üíä</span>
							<strong>Network Health</strong>
							<span id="health-help" class="help-icon" title="Overall network health based on connectivity, engagement, and growth">?</span>
						</div>
						<div class="health-display">
							<div class="health-score-container">
								<div id="health-score" class="health-score">--</div>
								<div id="health-status" class="health-status">Loading...</div>
							</div>
							<div class="health-bar-container">
								<div id="health-bar" class="health-bar" style="width: 0%"></div>
							</div>
						</div>
						<div id="health-breakdown" class="health-breakdown" style="display:none;">
							<div class="health-metric">
								<span class="metric-label">Connectivity</span>
								<div class="metric-bar-bg"><div id="connectivity-bar" class="metric-bar"></div></div>
								<span id="connectivity-value" class="metric-value">--</span>
							</div>
							<div class="health-metric">
								<span class="metric-label">Engagement</span>
								<div class="metric-bar-bg"><div id="engagement-bar" class="metric-bar"></div></div>
								<span id="engagement-value" class="metric-value">--</span>
							</div>
							<div class="health-metric">
								<span class="metric-label">Growth</span>
								<div class="metric-bar-bg"><div id="growth-bar" class="metric-bar"></div></div>
								<span id="growth-value" class="metric-value">--</span>
							</div>
						</div>
						<button id="toggle-health-details" class="retro-btn retro-btn-sm" style="margin-top:6px; width:100%;">Show Details</button>
					</div>

					<!-- Engagement Section -->
					<div id="engagement-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">üë•</span>
							<strong>User Engagement</strong>
							<span class="help-icon" title="How active users are on the platform">?</span>
						</div>
						<div class="engagement-display">
							<div class="engagement-stat">
								<div id="engagement-score" class="stat-number">--</div>
								<div class="stat-label">Score</div>
							</div>
							<div class="engagement-stat">
								<div id="active-users-pct" class="stat-number">--%</div>
								<div class="stat-label">Active</div>
							</div>
							<div class="engagement-stat">
								<div id="avg-reviews" class="stat-number">--</div>
								<div class="stat-label">Avg Reviews</div>
							</div>
						</div>
					</div>

					<!-- Trend Section -->
					<div id="trend-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">üìä</span>
							<strong>Network Trend</strong>
							<span class="help-icon" title="Is the network growing, declining, or stable?">?</span>
						</div>
						<div class="trend-display">
							<div id="trend-indicator" class="trend-indicator">
								<span id="trend-icon" class="trend-icon">‚è≥</span>
								<span id="trend-text" class="trend-text">Loading...</span>
							</div>
							<div class="trend-stats">
								<div class="trend-stat">
									<span class="stat-label">Volatility:</span>
									<span id="volatility-value" class="stat-value">--</span>
								</div>
								<div class="trend-stat">
									<span class="stat-label">Growth:</span>
									<span id="growth-pct" class="stat-value">--%</span>
								</div>
							</div>
						</div>
					</div>

					<!-- Top Influencers Section -->
					<div id="influencers-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">‚≠ê</span>
							<strong>Top Influencers</strong>
							<span class="help-icon" title="Most influential users and movies in the network">?</span>
						</div>
						<div class="influencers-tabs">
							<button id="tab-users" class="tab-btn active" onclick="switchInfluencerTab('users')">Users</button>
							<button id="tab-movies" class="tab-btn" onclick="switchInfluencerTab('movies')">Movies</button>
						</div>
						<div id="influencers-content-users" class="influencers-content">
							<div id="top-users-list" class="influencer-list">
								<div class="influencer-placeholder">Loading...</div>
							</div>
						</div>
						<div id="influencers-content-movies" class="influencers-content" style="display:none;">
							<div id="top-movies-list" class="influencer-list">
								<div class="influencer-placeholder">Loading...</div>
							</div>
						</div>
					</div>

					<!-- Quick Stats -->
					<div id="quick-stats-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">üìà</span>
							<strong>Quick Stats</strong>
						</div>
						<div class="quick-stats-grid">
							<div class="quick-stat">
								<div class="quick-stat-label">Density</div>
								<div id="density-value" class="quick-stat-value">--</div>
							</div>
							<div class="quick-stat">
								<div class="quick-stat-label">Avg Degree</div>
								<div id="avg-degree-value" class="quick-stat-value">--</div>
							</div>
							<div class="quick-stat">
								<div class="quick-stat-label">Clustering</div>
								<div id="clustering-value" class="quick-stat-value">--</div>
							</div>
							<div class="quick-stat">
								<div class="quick-stat-label">Components</div>
								<div id="components-value" class="quick-stat-value">--</div>
							</div>
						</div>
					</div>

					<!-- Communities Section -->
					<div id="communities-section" class="analytics-section">
						<div class="section-header">
							<span class="section-icon">üåê</span>
							<strong>Communities</strong>
							<span class="help-icon" title="Detected clusters of densely connected nodes">?</span>
						</div>
						<div class="community-stats">
							<div class="community-stat">
								<div class="stat-label">Count:</div>
								<div id="community-count" class="stat-value">--</div>
							</div>
							<div class="community-stat">
								<div class="stat-label">Method:</div>
								<div id="community-method" class="stat-value">--</div>
							</div>
							<div class="community-stat">
								<div class="stat-label">Modularity:</div>
								<div id="community-modularity" class="stat-value">--</div>
							</div>
						</div>
						<div id="community-list" class="community-list" style="margin-top:8px; max-height:200px; overflow-y:auto;">
							<div class="influencer-placeholder">Loading...</div>
						</div>
					</div>
				</div>
			</div>
			<div class="window panel">
				<div class="title-bar"><div>Tips</div><div class="title-bar-controls"></div></div>
				<div class="window-body" style="font-size:12px;">
					<ul style="padding-left:18px; margin:0;">
						<li>Hover nodes for details</li>
						<li>Drag to reposition</li>
						<li>Scroll to zoom</li>
						<li>Click a movie to open its page</li>
						<li>Dashed edges connect similar users</li>
					</ul>
				</div>
			</div>
		</div>
		<div class="right-column">
			<div class="window" style="height:100%;">
				<div class="title-bar"><div>Visualization</div><div class="title-bar-controls"></div></div>
				<div class="window-body" style="padding:8px;">
					<div id="network-visualization"></div>
					<div id="predictions-panel" style="margin-top:6px; font-size:11px; display:none;">
						<strong>Top Predictions</strong>
						<ol id="predictions-list" style="padding-left:18px; margin:4px 0 0 0; max-height:140px; overflow:auto; line-height:1.25;"></ol>
					</div>
					<div id="loading" class="center-box" style="display:none;">Loading network data...</div>
					<div id="error-message" class="center-box error" style="display:none;"></div>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- ============================================================================
     NODE DETAIL MODAL
     ============================================================================ -->
<div id="node-modal" class="modal" style="display:none;">
	<div class="modal-overlay" onclick="closeNodeModal()"></div>
	<div class="window modal-window">
		<div class="title-bar">
			<div id="modal-title">Node Details</div>
			<div class="title-bar-controls">
				<button onclick="closeNodeModal()">‚úï</button>
			</div>
		</div>
		<div class="window-body modal-body">
			<div id="modal-content">
				<div class="modal-loading">Loading...</div>
			</div>
		</div>
		<div class="modal-footer">
			<button class="retro-btn" onclick="closeNodeModal()">Close</button>
			<button id="modal-view-page" class="retro-btn" style="display:none;" onclick="viewNodePage()">View Page</button>
		</div>
	</div>
</div>

<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script src="{% static 'js/graph-layout-config.js' %}"></script>
<script>
// ============================================================================
// GLOBAL STATE
// ============================================================================

// Network instance and data
let network = null;
let currentData = { nodes: [], edges: [] };

// User preferences
let chaosModeEnabled = false;   // Whether chaos mode (actors/crew) is active

// Performance optimization
let tooltipCache = new Map();   // Cache node tooltips to reduce computation
let tooltipTimeout = null;      // Debounce tooltip display

// ============================================================================
// NETWORK INITIALIZATION
// ============================================================================

function initNetwork() {
	/**
	 * Initialize the vis.js network with MultiGravity Force Atlas configuration.
	 * Sets up the visualization container, physics engine, and event handlers.
	 */
	const container = document.getElementById('network-visualization');
	
	// Base visual configuration for nodes and edges
	const baseOptions = {
		nodes: { 
			borderWidth: 2, 
			shape: 'dot', 
			font: { color: '#fff', size: 12, strokeWidth: 2, strokeColor: '#000' },
			chosen: false  // Disable selection highlighting for performance
		},
		edges: { 
			smooth: { type: 'continuous', forceDirection: 'none', roundness: 0.1 }, 
			shadow: false,  // Disable shadows for better performance
			width: 1,       // Thin edges for performance
			selectionWidth: 1  // Disable edge selection width changes
		},
		interaction: { 
			hover: true, 
			tooltipDelay: 200,  // Delay before showing tooltips
			hideEdgesOnDrag: true,  // Hide edges while dragging for performance
			hideNodesOnDrag: false
		}
	};
	
	// Standard Force-Directed Layout physics configuration
	const standardPhysics = {
		enabled: true,
		stabilization: {
			enabled: true,
			iterations: 1000,
			updateInterval: 50,
			onlyDynamicEdges: false,
			fit: true
		},
		solver: 'forceAtlas2Based',
		forceAtlas2Based: {
			theta: 0.5,
			gravitationalConstant: -50,
			centralGravity: 0.01,
			springLength: 100,
			springConstant: 0.08,
			damping: 0.4,
			avoidOverlap: 0.5
		},
		maxVelocity: 50,
		minVelocity: 0.1,
		timestep: 0.5,
		adaptiveTimestep: true
	};
	
	// Combine all configuration
	const options = {
		...baseOptions,
		layout: {
			improvedLayout: true,
			clusterThreshold: 150,
			randomSeed: 42  // Reproducible layout
		},
		physics: standardPhysics,
		configure: { enabled: false }
	};
	
	// Create the network instance
	network = new vis.Network(container, { nodes: [], edges: [] }, options);
	
	// ========== ALWAYS-ON PHYSICS - NO AUTO-PAUSE ==========
	// Physics remain continuously active for smooth, organic graph behavior
	// Users can drag nodes and the graph adapts in real-time
	
	// Event listeners for user interactions
	network.on('hoverNode', (params) => {
		showNodeTooltip(params);
		highlightNeighbors(params.node);
	});
	network.on('blurNode', () => {
		hideNodeTooltip();
		resetHighlight();
	});
	network.on('click', params => { 
		if (params.nodes.length) { 
			handleNodeClick(params.nodes[0]); 
		}
	});
}

async function loadGraph(){
	const loading=document.getElementById('loading'); const err=document.getElementById('error-message');
	loading.style.display='flex'; err.style.display='none';
	
	// Clear tooltip cache on new data load
	tooltipCache.clear();
	
	try {
		const qs = new URLSearchParams({ 
			min_reviews: document.getElementById('min-reviews').value, 
			rating_threshold: document.getElementById('rating-threshold').value, 
			max_nodes: document.getElementById('max-nodes').value, 
			predictions_limit: document.getElementById('predictions-limit').value, 
			movie_limit: document.getElementById('movie-limit').value
		});
		if(chaosModeEnabled){ qs.append('chaos','1'); }
		// add filter params
		document.querySelectorAll('.ng-filter').forEach(cb=>{ qs.append(cb.dataset.param, cb.checked ? '1':'0'); });
		
		const loadStart = performance.now();
		const res = await fetch(`/movies/network-graph/data/?${qs.toString()}`);
		if(!res.ok) throw new Error('HTTP '+res.status);
		const data = await res.json(); 
		const loadTime = performance.now() - loadStart;
		
		console.log(`Data loaded in ${loadTime.toFixed(1)}ms - ${data.nodes?.length || 0} nodes, ${data.edges?.length || 0} edges`);
		console.log('Analytics data:', {
			health: data.health,
			engagement: data.engagement,
			temporal: data.temporal_metrics,
			top_influencers: data.top_influencers
		});
		
		currentData = data; 
		updateNetwork(); 
		updateStats(data.stats);
	} catch(e){ console.error(e); err.textContent='Failed to load graph: '+e.message; err.style.display='flex'; }
	finally { loading.style.display='none'; }
}

function updateNetwork(){
	if(!network) return;
	
	// Use MultiGravity Force Atlas layout with analytics-enhanced visualization
	const filteredData = filterGraphData(currentData);
	const nodeCount = filteredData.nodes.length;
	const edgeCount = filteredData.edges.length;
	const density = nodeCount > 1 ? (2 * edgeCount) / (nodeCount * (nodeCount - 1)) : 0;
	
	// Get analytics data for enhanced visualization
	const communitiesData = currentData?.analytics?.communities?.communities || {};
	const nodeToComm = currentData?.analytics?.communities?.node_to_community || {};
	const centrality = currentData?.analytics?.centrality?.centrality_measures || {};
	const topInfluencers = currentData?.top_influencers || {};
	
	// ========== FORCE-DIRECTED LAYOUT CONFIGURATION ==========
	// Use backend layout config if available (basic parameters only)
	const layoutConfig = filteredData.layout_config || {};
	
	// Extract basic physics parameters
	const theta = layoutConfig.theta || 0.5;
	const baseRepulsion = layoutConfig.base_repulsion || -50;
	const springConstant = layoutConfig.spring_constant || 0.08;
	const damping = layoutConfig.damping || 0.4;
	const avoidOverlap = layoutConfig.avoid_overlap || 0.5;
	const stabilizationIterations = layoutConfig.stabilization_iterations || Math.min(1000, nodeCount * 5);
	const maxVelocity = layoutConfig.max_velocity || 50;
	const minVelocity = layoutConfig.min_velocity || 0.1;
	const timestep = layoutConfig.timestep || 0.5;
	
	// Always-on physics with smooth, stable behavior
	const physicsConfig = {
		physics: {
			enabled: true,
			solver: 'forceAtlas2Based',
			forceAtlas2Based: {
				theta: theta,
				gravitationalConstant: baseRepulsion,
				centralGravity: 0.002, // Reduced from 0.01 to prevent big nodes clustering in center
				springLength: Math.max(100, 100 + (density * 30)),
				springConstant: springConstant,
				damping: Math.max(damping, 0.5), // Ensure minimum damping to prevent spinning
				avoidOverlap: avoidOverlap
			},
			stabilization: {
				enabled: true,
				iterations: stabilizationIterations,
				updateInterval: 50,
				onlyDynamicEdges: false,
				fit: true
			},
			maxVelocity: maxVelocity,
			minVelocity: minVelocity,
			timestep: timestep,
			adaptiveTimestep: true
		}
	};
	
	// Apply configuration
	network.setOptions(physicsConfig);
	
	console.log('üéØ Force-Directed Layout Configuration:', {
		nodeCount, 
		edgeCount, 
		density: density.toFixed(3),
		physics: {
			theta, baseRepulsion, springConstant, damping, 
			avoidOverlap, maxVelocity, minVelocity, timestep
		}
	});
	
	const isLargeGraph = nodeCount > 100;
	
	// ========== ANALYTICS-ENHANCED NODE STYLING ==========
	const styledNodes = filteredData.nodes.map(n=> {
		// Find influence score
		let influenceScore = 0;
		if (n.type === 'user') {
			const inf = topInfluencers.users?.find(u => u.id === n.id);
			influenceScore = inf?.influence_score || 0;
		} else if (n.type === 'movie') {
			const inf = topInfluencers.movies?.find(m => m.id === n.id);
			influenceScore = inf?.influence_score || 0;
		}
		
		// Find community
		const communityId = nodeToComm[n.id];
		const communityInfo = communityId ? communitiesData[communityId] : null;
		
		// Find centrality
		const centralityMeasures = centrality[n.id] || {};
		const centralityScore = centralityMeasures.degree_centrality || 0;
		
		// Base node properties
		const node = {
			id: n.id,
			label: isLargeGraph && n.label?.length > 15 ? n.label.substring(0, 12) + '...' : n.label,
			fullLabel: n.label,  // Store full label for tooltips and modals
			group: n.group,
			type: n.type,
			// No title property - we use custom tooltip to avoid duplicates
			community: communityId,
			community_name: communityInfo?.name,
			community_size: communityInfo?.size,
			community_density: communityInfo?.density,
			// Copy additional properties from original node
			review_count: n.review_count,
			reviews: n.reviews,
			degree: n.degree,
			avg_rating: n.avg_rating,
			rating: n.rating,
			year: n.year,
			movie_count: n.movie_count,
			profile_picture: n.profile_picture,
			tmdb_id: n.tmdb_id,
			// Add centrality measures for tooltips
			centrality: centralityMeasures
		};
		
		// ========== SIZE BASED ON INFLUENCE + CENTRALITY ==========
		// Combine influence score and centrality for size
		const baseSize = n.size || 15;
		const influenceFactor = influenceScore > 0 ? 1 + (influenceScore / 100) : 1;
		const centralityFactor = centralityScore > 0 ? 1 + (centralityScore * 0.5) : 1;
		
		node.size = baseSize * Math.min(influenceFactor, 2) * Math.min(centralityFactor, 1.5);
		
		// ========== COLOR BASED ON COMMUNITY ==========
		if (communityId !== undefined) {
			// Use community colors
			const communityColors = [
				'#4299E1', '#F56565', '#48BB78', '#9F7AEA', '#ED8936', '#FFD700',
				'#00CED1', '#FF69B4', '#32CD32', '#FF6347', '#DA70D6', '#20B2AA',
				'#FF4500', '#1E90FF', '#228B22', '#DC143C', '#8A2BE2', '#FF1493'
			];
			const colorIndex = communityId % communityColors.length;
			node.color = {
				background: communityColors[colorIndex],
				border: communityColors[colorIndex],
				highlight: {
					background: communityColors[colorIndex],
					border: '#FFD700'
				},
				hover: {
					background: communityColors[colorIndex],
					border: '#FFFFFF'
				}
			};
		} else {
			// Default type-based colors
			const typeColors = {
				user: '#4299E1',
				movie: '#F56565',
				genre: '#9F7AEA',
				country: '#48BB78',
				director: '#ED8936',
				actor: '#FFD700',
				crew: '#00CED1',
				prediction: '#FFD700'
			};
			const baseColor = typeColors[n.type] || '#808080';
			node.color = {
				background: baseColor,
				border: baseColor,
				highlight: {
					background: baseColor,
					border: '#FFD700'
				},
				hover: {
					background: baseColor,
					border: '#FFFFFF'
				}
			};
		}
		
		// ========== BORDER WIDTH FOR INFLUENCERS ==========
		if (influenceScore > 50) {
			node.borderWidth = 3;
			node.borderWidthSelected = 5;
		} else if (influenceScore > 20) {
			node.borderWidth = 2;
			node.borderWidthSelected = 4;
		} else {
			node.borderWidth = 1;
			node.borderWidthSelected = 3;
		}
		
		// ========== SHAPE BASED ON TYPE ==========
		const typeShapes = {
			user: 'dot',
			movie: 'square',
			genre: 'diamond',
			country: 'triangle',
			director: 'star',
			actor: 'dot',
			crew: 'dot',
			prediction: 'box'
		};
		node.shape = typeShapes[n.type] || 'dot';
		
		// ========== MASS BASED ON CENTRALITY FOR BETTER SPREADING ==========
		// High-centrality nodes have more mass, pushing others away for better distribution
		// Base mass from backend, enhanced by centrality (keep multiplier modest to avoid instability)
		const baseMass = n.mass || 1;
		const centralityMass = centralityScore > 0 ? 1 + (centralityScore * 0.3) : 1; // Up to 1.3x mass (reduced from 3x)
		node.mass = baseMass * centralityMass;
		
		// Apply MultiGravity properties from backend for initial positioning (override mass if backend provides it)
		if (n.mass !== undefined) node.mass = n.mass * centralityMass;
		if (n.preferred_x !== undefined) node.x = n.preferred_x;
		if (n.preferred_y !== undefined) node.y = n.preferred_y;
		if (n.gravity_center_x !== undefined) {
			// Use gravity center as initial position hint with randomization
			node.x = n.gravity_center_x + (Math.random() - 0.5) * 150;
		}
		if (n.gravity_center_y !== undefined) {
			node.y = n.gravity_center_y + (Math.random() - 0.5) * 150;
		}
		
		return node;
	});
	
	// ========== ENHANCED EDGE STYLING ==========
	const styledEdges = filteredData.edges.map(e => {
		const edge = {
			from: e.from || e.source,
			to: e.to || e.target,
			type: e.type
		};
		
		// ========== CENTRALITY-BASED EDGE LENGTHS FOR SPREADING ==========
		// Edges connected to high-centrality nodes are longer, pushing the graph apart
		const fromCentrality = centrality[edge.from]?.degree_centrality || 0;
		const toCentrality = centrality[edge.to]?.degree_centrality || 0;
		const maxCentrality = Math.max(fromCentrality, toCentrality);
		const centralityLengthMultiplier = 1 + (maxCentrality * 0.3); // Up to 1.3x longer (reduced from 1.8x)
		
		// Apply MultiGravity edge properties from backend
		const baseLength = e.length || 90;
		edge.length = baseLength * centralityLengthMultiplier;
		
		if (e.strength !== undefined) {
			edge.spring = {
				length: edge.length,
				constant: e.strength
			};
		}
		
		// Edge styling based on type and strength
		if (e.type === 'prediction') { 
			edge.dashes = false; 
			edge.color = { color: '#FFD700' }; 
			edge.width = isLargeGraph ? 2 : 3;
		} else if (e.type && e.type.includes('affinity')) { 
			edge.dashes = !isLargeGraph;
			if (!isLargeGraph) edge.smooth = { enabled: true, type: 'dynamic' };
			edge.width = Math.min(3, 2);
			edge.color = { color: '#999', opacity: isLargeGraph ? 0.3 : 0.6 };
		} else if (e.type === 'similarity') { 
			edge.dashes = !isLargeGraph;
			edge.color = { color: '#999', opacity: isLargeGraph ? 0.2 : 0.5 };
			edge.width = isLargeGraph ? 1 : 2;
		} else {
			edge.color = e.color || { color: '#848484', opacity: isLargeGraph ? 0.4 : 0.7 };
			edge.width = isLargeGraph ? 1 : (e.width || 2);
		}
		
		// Copy metadata
		if (e.weight) edge.weight = e.weight;
		if (e.label && !isLargeGraph) edge.label = e.label;
		if (e.metadata) edge.metadata = e.metadata;
		
		return edge;
	});
	
	// ========== SMOOTH GRAPH UPDATE WITH ALWAYS-ON PHYSICS ==========
	const updateStart = performance.now();
	
	// For large graphs, temporarily disable physics during data update for performance
	if (nodeCount > 150) {
		network.setOptions({ physics: { enabled: false } });
	}
	
	// Update graph data
	network.setData({ nodes: styledNodes, edges: styledEdges });
	
	// Re-enable physics after brief delay
	if (nodeCount > 150) {
		setTimeout(() => {
			network.setOptions(physicsConfig);
		}, 100);
	}
	
	const updateTime = performance.now() - updateStart;
	if (updateTime > 100) {
		console.log(`Graph update took ${updateTime.toFixed(1)}ms for ${nodeCount} nodes, ${edgeCount} edges`);
	}
	
	// Always keep physics running - no auto-pause behavior
	// Users can still drag nodes and the graph will adapt smoothly
	
	renderPredictionsList();
}

// Filter graph data based on visibility toggles
function filterGraphData(data) {
    // Get filter states
    const getFilterState = (param) => {
        const checkbox = document.querySelector(`.ng-filter[data-param="${param}"]`);
        return checkbox ? checkbox.checked : true;
    };
    
    const showUsers = getFilterState('users');
    const showMovies = getFilterState('movies');
    const showCountries = getFilterState('countries');
    const showGenres = getFilterState('genres');
    const showDirectors = getFilterState('directors');
    const showActors = getFilterState('actors');
    const showCrew = getFilterState('crew');
    
    const showReviews = getFilterState('reviews');
    const showSimilarity = getFilterState('similarity');
    const showPredictions = getFilterState('predictions');
    const showRelationships = getFilterState('relationships');
    const showAffinity = getFilterState('affinity');
    
    // Filter nodes based on type visibility
    const visibleNodeTypes = [];
    if (showUsers) visibleNodeTypes.push('user');
    if (showMovies) visibleNodeTypes.push('movie');
    if (showCountries) visibleNodeTypes.push('country');
    if (showGenres) visibleNodeTypes.push('genre');
    if (showDirectors) visibleNodeTypes.push('director');
    if (showActors) visibleNodeTypes.push('actor');
    if (showCrew) visibleNodeTypes.push('crew');
    
    const filteredNodes = data.nodes.filter(node => visibleNodeTypes.includes(node.type));
    
    // Get IDs of visible nodes for edge filtering
    const visibleNodeIds = new Set(filteredNodes.map(node => node.id));
    
    // Filter edges based on type and connected nodes
    const filteredEdges = data.edges.filter(edge => {
        // Check if both connected nodes are visible
        if (!visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
            return false;
        }
        
        // Check edge type visibility
        const edgeType = edge.type || 'review'; // Default to review if no type specified
        
        // Group edge types for filtering
        if (edgeType === 'review' && !showReviews) return false;
        if (edgeType === 'similarity' && !showSimilarity) return false;
        if (edgeType === 'prediction' && !showPredictions) return false;
        
        // Relationships: movie connections to countries, genres, directors, actors, crew
        const relationshipTypes = ['origin', 'genre', 'directed_by', 'acted_in', 'crew'];
        if (relationshipTypes.includes(edgeType) && !showRelationships) return false;
        
        // Affinity: all dashed affinity edges
        const affinityTypes = ['user_genre_affinity', 'user_country_affinity', 'actor_genre_affinity', 
                              'actor_country_affinity', 'director_genre_affinity', 'director_country_affinity'];
        if (affinityTypes.includes(edgeType) && !showAffinity) return false;
        
        return true;
    });
    
    return {
        nodes: filteredNodes,
        edges: filteredEdges,
        stats: data.stats // Keep original stats for display
    };
}

function renderPredictionsList(){
	const panel=document.getElementById('predictions-panel'); const list=document.getElementById('predictions-list'); if(!panel||!list) return;
	const preds=currentData.nodes.filter(n=> n.predicted_score).sort((a,b)=> b.predicted_score - a.predicted_score).slice(0,25);
	if(!preds.length){ panel.style.display='none'; list.innerHTML=''; return; }
	panel.style.display='block';
	list.innerHTML=preds.map(p=>`<li><span style="color:#FFD700; font-weight:600;">${p.predicted_score}</span> ${p.label} ${p.predicted_confidence? '<span style="opacity:.7;">['+p.predicted_confidence+']</span>':''}</li>`).join('');
}


function updateStats(s){ 
	const list=document.getElementById('stats-list'); 
	if(!s){ list.innerHTML='<li><span>No data</span></li>'; return;} 
	
	// Get filtered data for accurate visible counts
	const filteredData = currentData ? filterGraphData(currentData) : { nodes: [], edges: [] };
	
	// Count visible nodes by type
	const nodeCounts = {};
	filteredData.nodes.forEach(node => {
		nodeCounts[node.type] = (nodeCounts[node.type] || 0) + 1;
	});
	
	list.innerHTML=`
		<li><span>Visible Nodes</span><span>${filteredData.nodes.length}</span></li>
		<li><span>Visible Edges</span><span>${filteredData.edges.length}</span></li>
		<li><span>Users</span><span>${nodeCounts.user || 0}</span></li>
		<li><span>Movies</span><span>${nodeCounts.movie || 0}</span></li>
		<li><span>Countries</span><span>${nodeCounts.country || 0}</span></li>
		<li><span>Genres</span><span>${nodeCounts.genre || 0}</span></li>
		<li><span>Directors</span><span>${nodeCounts.director || 0}</span></li>
		<li><span>Pred Edges</span><span>${filteredData.edges.filter(e => e.type === 'prediction').length}</span></li>
		${s.hub_user ? `<li><span>Hub User</span><span>${s.hub_max_reviews} reviews</span></li>`:''}
		<li class="chaos-only" style="display:${chaosModeEnabled && (nodeCounts.actor || 0) > 0 ? 'flex':'none'}; justify-content:space-between;"><span>Actors</span><span>${nodeCounts.actor || 0}</span></li>
		<li class="chaos-only" style="display:${chaosModeEnabled && (nodeCounts.crew || 0) > 0 ? 'flex':'none'}; justify-content:space-between;"><span>Crew</span><span>${nodeCounts.crew || 0}</span></li>
		<li style="border-top: 1px solid var(--border-dark); margin-top: 0.5rem; padding-top: 0.5rem;"><span>Total (All)</span><span>${s.total_nodes}</span></li>`; 
	document.querySelectorAll('.legend-list .chaos-only').forEach(el=>{ el.style.display = chaosModeEnabled ? 'flex':'none'; }); 

	// Update analytics if available (Phase 2B)
	updateAnalyticsPanel();
}

function updateAnalyticsPanel() {
	const health = currentData?.health;
	const engagement = currentData?.engagement;
	const temporal = currentData?.temporal_metrics;
	const topInfluencers = currentData?.top_influencers;
	
	// ========== UPDATE HEALTH SECTION ==========
	if (health) {
		const healthScore = Math.round(health.overall_health || 0);
		const healthStatus = (health.status || 'unknown').toLowerCase();
		
		// Update health score and status
		const healthScoreEl = document.getElementById('health-score');
		const healthStatusEl = document.getElementById('health-status');
		const healthBarEl = document.getElementById('health-bar');
		const badgeEl = document.getElementById('analytics-badge');
		
		if (healthScoreEl) {
			healthScoreEl.textContent = healthScore;
			healthScoreEl.className = 'health-score ' + healthStatus;
		}
		if (healthStatusEl) {
			healthStatusEl.textContent = healthStatus.toUpperCase();
			healthStatusEl.className = 'health-status ' + healthStatus;
		}
		if (healthBarEl) {
			healthBarEl.style.width = healthScore + '%';
			healthBarEl.className = 'health-bar ' + healthStatus;
		}
		if (badgeEl) {
			badgeEl.style.display = 'inline-block';
		}
		
		// Update health breakdown
		const metrics = health.metrics || {};
		updateMetricBar('connectivity', health.connectivity_health || 0, 30);
		updateMetricBar('engagement', health.engagement_health || 0, 40);
		updateMetricBar('growth', health.growth_health || 0, 30);
		
		// Update quick stats
		updateQuickStat('density', metrics.density);
		updateQuickStat('avg-degree', metrics.average_degree);
		updateQuickStat('clustering', metrics.clustering_coefficient);
		updateQuickStat('components', metrics.connected_components);
	}
	
	// ========== UPDATE ENGAGEMENT SECTION ==========
	if (engagement) {
		const engagementScore = Math.round(engagement.engagement_score || 0);
		const activeUsers = engagement.active_users || 0;
		const totalUsers = engagement.total_users || 1;
		const activePct = Math.round((activeUsers / totalUsers) * 100);
		const avgReviews = (engagement.average_reviews_per_user || 0).toFixed(1);
		
		updateStatNumber('engagement-score', engagementScore);
		updateStatNumber('active-users-pct', activePct + '%');
		updateStatNumber('avg-reviews', avgReviews);
	}
	
	// ========== UPDATE TREND SECTION ==========
	if (temporal) {
		const trend = temporal.trend || 'stable';
		const volatility = (temporal.volatility || 0).toFixed(2);
		const trendChange = temporal.trend_change || 0;
		const growthPct = (trendChange > 0 ? '+' : '') + trendChange.toFixed(1) + '%';
		
		// Trend icon and text
		const trendIconEl = document.getElementById('trend-icon');
		const trendTextEl = document.getElementById('trend-text');
		
		const trendIcons = {
			'growing': 'üìà',
			'declining': 'üìâ',
			'stable': '‚û°Ô∏è'
		};
		
		if (trendIconEl) trendIconEl.textContent = trendIcons[trend] || '‚è≥';
		if (trendTextEl) {
			trendTextEl.textContent = trend.charAt(0).toUpperCase() + trend.slice(1);
			trendTextEl.className = 'trend-text ' + trend;
		}
		
		// Trend stats
		const volatilityEl = document.getElementById('volatility-value');
		const growthPctEl = document.getElementById('growth-pct');
		
		if (volatilityEl) volatilityEl.textContent = volatility;
		if (growthPctEl) {
			growthPctEl.textContent = growthPct;
			growthPctEl.style.color = trendChange > 0 ? '#48BB78' : trendChange < 0 ? '#F56565' : '#4299E1';
		}
	}
	
	// ========== UPDATE INFLUENCERS SECTION ==========
	if (topInfluencers) {
		updateInfluencerList('users', topInfluencers.users || []);
		updateInfluencerList('movies', topInfluencers.movies || []);
	}
	
	// ========== UPDATE COMMUNITIES SECTION ==========
	const communities = currentData?.analytics?.communities;
	if (communities) {
		updateCommunitiesSection(communities);
	}
}

// Helper functions for analytics updates
function updateMetricBar(metric, value, maxValue) {
	const barEl = document.getElementById(`${metric}-bar`);
	const valueEl = document.getElementById(`${metric}-value`);
	const percentage = Math.min(100, (value / maxValue) * 100);
	
	if (barEl) barEl.style.width = percentage + '%';
	if (valueEl) valueEl.textContent = value.toFixed(1);
}

function updateStatNumber(id, value) {
	const el = document.getElementById(id);
	if (el) el.textContent = value;
}

function updateQuickStat(id, value) {
	const el = document.getElementById(`${id}-value`);
	if (el && value !== undefined) {
		el.textContent = typeof value === 'number' ? value.toFixed(3) : value;
	}
}

function updateInfluencerList(type, influencers) {
	const listEl = document.getElementById(`top-${type}-list`);
	if (!listEl) return;
	
	if (!influencers || influencers.length === 0) {
		listEl.innerHTML = '<div class="influencer-placeholder">No data available</div>';
		return;
	}
	
	const html = influencers.slice(0, 5).map((inf, index) => {
		const rank = index + 1;
		const score = Math.round(inf.influence_score || 0);
		const label = inf.label || 'Unknown';
		const reviewCount = inf.review_count || 0;
		const rankClass = rank <= 3 ? `rank-${rank}` : '';
		
		return `
			<div class="influencer-card" onclick="handleNodeClick('${inf.id}')">
				<div class="influencer-rank ${rankClass}">#${rank}</div>
				<div class="influencer-details">
					<div class="influencer-name" title="${label}">${label}</div>
					<div class="influencer-meta">${reviewCount} review${reviewCount !== 1 ? 's' : ''}</div>
				</div>
				<div class="influencer-score">${score}</div>
			</div>
		`;
	}).join('');
	
	listEl.innerHTML = html;
}

function updateCommunitiesSection(communities) {
	// Update stats
	const countEl = document.getElementById('community-count');
	const methodEl = document.getElementById('community-method');
	const modularityEl = document.getElementById('community-modularity');
	
	const count = communities.community_count || 0;
	const method = (communities.method || 'unknown').replace('_', ' ');
	const modularity = communities.modularity || 0;
	
	if (countEl) countEl.textContent = count;
	if (methodEl) methodEl.textContent = method.charAt(0).toUpperCase() + method.slice(1);
	if (modularityEl) modularityEl.textContent = modularity.toFixed(3);
	
	// Update community list
	const listEl = document.getElementById('community-list');
	if (!listEl) return;
	
	const communitiesData = communities.communities || {};
	const communityArray = Object.entries(communitiesData).map(([id, data]) => ({
		id,
		...data
	}));
	
	if (communityArray.length === 0) {
		listEl.innerHTML = '<div class="influencer-placeholder">No communities detected</div>';
		return;
	}
	
	// Sort by size (largest first)
	communityArray.sort((a, b) => (b.size || 0) - (a.size || 0));
	
	// Community colors matching the node colors
	const communityColors = [
		'#4299E1', '#F56565', '#48BB78', '#9F7AEA', '#ED8936', '#FFD700',
		'#00CED1', '#FF69B4', '#32CD32', '#FF6347', '#DA70D6', '#20B2AA',
		'#FF4500', '#1E90FF', '#228B22', '#DC143C', '#8A2BE2', '#FF1493'
	];
	
	const html = communityArray.slice(0, 10).map((comm, index) => {
		const commNum = parseInt(comm.id.replace('community_', ''));
		const colorIndex = commNum % communityColors.length;
		const color = communityColors[colorIndex];
		const name = comm.name || `Community ${commNum}`;
		const size = comm.size || 0;
		const density = comm.density !== undefined ? (comm.density * 100).toFixed(0) + '%' : 'N/A';
		
		return `
			<div class="community-item" title="${name}">
				<div class="community-color" style="background-color: ${color};"></div>
				<div class="community-info">
					<div class="community-name">${name}</div>
					<div class="community-meta">Density: ${density}</div>
				</div>
				<div class="community-size">${size}</div>
			</div>
		`;
	}).join('');
	
	listEl.innerHTML = html;
}

// Tab switching for influencers
function switchInfluencerTab(tab) {
	// Update tab buttons
	document.getElementById('tab-users')?.classList.toggle('active', tab === 'users');
	document.getElementById('tab-movies')?.classList.toggle('active', tab === 'movies');
	
	// Update content visibility
	document.getElementById('influencers-content-users').style.display = tab === 'users' ? 'block' : 'none';
	document.getElementById('influencers-content-movies').style.display = tab === 'movies' ? 'block' : 'none';
}

// Toggle health details
document.addEventListener('DOMContentLoaded', () => {
	const toggleBtn = document.getElementById('toggle-health-details');
	const breakdownEl = document.getElementById('health-breakdown');
	
	if (toggleBtn && breakdownEl) {
		toggleBtn.addEventListener('click', () => {
			const isVisible = breakdownEl.style.display !== 'none';
			breakdownEl.style.display = isVisible ? 'none' : 'block';
			toggleBtn.textContent = isVisible ? 'Show Details' : 'Hide Details';
		});
	}
});

function refreshFilterVisuals(){
	document.querySelectorAll('.ng-filter-label').forEach(lbl=>{
		const cb = lbl.querySelector('input.ng-filter');
		if(!cb) return;
		lbl.classList.toggle('active', cb.checked);
		lbl.classList.toggle('inactive', !cb.checked);
		const span = lbl.querySelector('.filter-text');
		if(!span) return;
		if(!span.dataset.baseText){ span.dataset.baseText = span.textContent.trim(); }
		if(!cb.checked){
			if(!span.textContent.includes('(hidden)')){ span.textContent = span.dataset.baseText + ' (hidden)'; }
		} else {
			if(span.textContent.trim() !== span.dataset.baseText){ span.textContent = span.dataset.baseText; }
		}
		// legend dimming
		const target = lbl.getAttribute('data-target');
		if(target){
			if(['actors','crew'].includes(target) && !chaosModeEnabled){
				return; // hidden already
			}
			let selectorMatch = '';
			if(target==='countries') selectorMatch = 'Countries';
			else if(target==='genres') selectorMatch = 'Genres';
			else if(target==='directors') selectorMatch = 'Directors';
			else if(target==='predictions') selectorMatch = 'Predictions';
			else if(target==='similarity') selectorMatch = 'Similar Users';
			else if(target==='actors') selectorMatch = 'Actors';
			else if(target==='crew') selectorMatch = 'Crew';
			if(selectorMatch){
				const legendItems = Array.from(document.querySelectorAll('.legend-list .legend-item'));
				const item = legendItems.find(li=> li.textContent.trim() === selectorMatch);
				if(item){ item.classList.toggle('disabled', !cb.checked); }
			}
		}
	});
}

// ============================================================================
// TOOLTIP SYSTEM
// ============================================================================

function showNodeTooltip(params){
	const id=params.node; 
	
	// Clear any pending tooltip
	if(tooltipTimeout) {
		clearTimeout(tooltipTimeout);
	}
	
	// Use cached tooltip if available
	if(tooltipCache.has(id)) {
		displayTooltip(tooltipCache.get(id));
		return;
	}
	
	// Debounce tooltip creation for performance
	tooltipTimeout = setTimeout(() => {
		const node=currentData.nodes.find(n=>n.id===id); 
		if(!node) return;
		
		const tooltipHtml = generateTooltipHtml(node);
		tooltipCache.set(id, tooltipHtml);
		displayTooltip(tooltipHtml);
	}, 50);
}

function generateTooltipHtml(node) {
	const displayLabel = node.fullLabel || node.label;
	let lines=[]; const header=`<strong>${displayLabel}</strong>`;
	if(node.type==='user'){
		lines.push('User'); lines.push('Reviews: '+(node.review_count||0));
	} else if(node.type==='movie') {
		lines.push('Movie');
		lines.push('Rating: '+(node.rating!==undefined? node.rating+'/10':'?'));
		if(node.year) lines.push('Year: '+node.year);
		if(node.predicted_score){
			lines.push(`<span style="color:#FFD700;">Pred: ${node.predicted_score}/10</span>`);
			if(node.content_similarity!==undefined) lines.push('Content sim: '+(node.content_similarity*100).toFixed(0)+'%');
			if(node.blend_w_cf!==undefined) lines.push('CF weight: '+(node.blend_w_cf*100).toFixed(0)+'%');
			if(node.predicted_contributors!==undefined) lines.push('Users: '+node.predicted_contributors);
			if(node.predicted_std_err!==undefined) lines.push('Std err: '+node.predicted_std_err);
		}
		if(node.genre_affinity!==undefined) lines.push(`<span style="color:#6B46C1;">Genre: ${(node.genre_affinity*100).toFixed(0)}%</span>`);
		if(node.country_affinity!==undefined) lines.push(`<span style="color:#2F855A;">Country: ${(node.country_affinity*100).toFixed(0)}%</span>`);
		if(node.director_affinity!==undefined) lines.push(`<span style="color:#D69E2E;">Director: ${(node.director_affinity*100).toFixed(0)}%</span>`);
		if(node.keyword_affinity!==undefined) lines.push(`<span style="color:#3182CE;">Keyword: ${(node.keyword_affinity*100).toFixed(0)}%</span>`);
		if(node.matched_keywords) lines.push('KW: '+node.matched_keywords.slice(0,4).join(', '));
	} else if(node.type==='country') { lines.push('Country Hub'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='genre') { lines.push('Genre Hub'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='director') { lines.push('Director'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='actor') { lines.push('Actor'); lines.push('Movies: '+node.movie_count); }
	else if(node.type==='crew') { lines.push('Crew'); lines.push('Movies: '+node.movie_count); }
	
	// Add analytics information (optimized)
	if(node.community !== undefined) {
		const communityName = node.community_name || `Community ${node.community.replace('community_', '')}`;
		lines.push(`<span style="color:#9F7AEA;">Community: ${communityName}</span>`);
		if(node.community_size !== undefined) {
			lines.push(`<span style="color:#9F7AEA;">Comm. Size: ${node.community_size}</span>`);
		}
	}
	if(node.centrality) {
		lines.push('<span style="color:#48BB78; font-weight:bold;">Centrality:</span>');
		if(node.centrality.degree !== undefined) lines.push(`Degree: ${node.centrality.degree.toFixed(3)}`);
		// Limit centrality display for performance
		if(lines.length < 12) {  // Don't show all centrality measures if tooltip is getting too long
			if(node.centrality.betweenness !== undefined) lines.push(`Betweenness: ${node.centrality.betweenness.toFixed(3)}`);
			if(node.centrality.closeness !== undefined) lines.push(`Closeness: ${node.centrality.closeness.toFixed(3)}`);
		}
	}
	
	return header+'<br>'+lines.join('<br>');
}

function displayTooltip(html) {
	hideNodeTooltip();  // Remove existing tooltip
	const t=document.createElement('div'); 
	t.id='node-tooltip'; 
	t.className='node-tooltip'; 
	t.innerHTML=html; 
	document.body.appendChild(t); 
	document.addEventListener('mousemove', positionTooltip);
}

function hideNodeTooltip(){ 
	if(tooltipTimeout) {
		clearTimeout(tooltipTimeout);
		tooltipTimeout = null;
	}
	const t=document.getElementById('node-tooltip'); 
	if(t){ 
		t.remove(); 
		document.removeEventListener('mousemove', positionTooltip);
	} 
}

function positionTooltip(e){ 
	const t=document.getElementById('node-tooltip'); 
	if(t){ 
		t.style.left=(e.pageX+12)+'px'; 
		t.style.top=(e.pageY+12)+'px'; 
	} 
}

// ============================================================================
// NEIGHBOR HIGHLIGHTING
// ============================================================================

let originalNodeColors = {};
let originalEdgeColors = {};

function highlightNeighbors(nodeId) {
	if (!network || !currentData) return;
	
	// Get connected nodes and edges
	const connectedNodes = network.getConnectedNodes(nodeId);
	const connectedEdges = network.getConnectedEdges(nodeId);
	
	// Create sets for fast lookup
	const highlightedNodes = new Set([nodeId, ...connectedNodes]);
	const highlightedEdges = new Set(connectedEdges);
	
	// Store original colors and update nodes
	const allNodes = currentData.nodes.map(node => {
		const isHighlighted = highlightedNodes.has(node.id);
		
		// Store original color if not already stored
		if (!originalNodeColors[node.id]) {
			originalNodeColors[node.id] = node.color;
		}
		
		return {
			id: node.id,
			color: isHighlighted ? node.color : addOpacity(node.color, 0.15),
			borderWidth: isHighlighted ? (node.id === nodeId ? 4 : 2) : 1,
			font: isHighlighted ? null : { color: 'rgba(128, 128, 128, 0.4)' }
		};
	});
	
	// Store original colors and update edges
	const allEdges = currentData.edges.map(edge => {
		const edgeId = edge.id || `${edge.source}-${edge.target}`;
		const isHighlighted = highlightedEdges.has(edgeId);
		
		// Store original color if not already stored
		if (!originalEdgeColors[edgeId]) {
			originalEdgeColors[edgeId] = edge.color || '#848484';
		}
		
		return {
			id: edgeId,
			color: isHighlighted ? 
				{ color: edge.color || '#848484', opacity: 1 } : 
				{ color: edge.color || '#848484', opacity: 0.1 },
			width: isHighlighted ? (edge.width || 1) * 1.5 : edge.width || 1
		};
	});
	
	// Update the network
	network.body.data.nodes.update(allNodes);
	network.body.data.edges.update(allEdges);
}

function resetHighlight() {
	if (!network || !currentData) return;
	
	// Restore all nodes to original colors
	const allNodes = currentData.nodes.map(node => ({
		id: node.id,
		color: originalNodeColors[node.id] || node.color,
		borderWidth: node.borderWidth || 1,
		font: null  // Reset to default (theme-aware)
	}));
	
	// Restore all edges to original colors
	const allEdges = currentData.edges.map(edge => {
		const edgeId = edge.id || `${edge.source}-${edge.target}`;
		return {
			id: edgeId,
			color: { color: originalEdgeColors[edgeId] || edge.color || '#848484', opacity: 1 },
			width: edge.width || 1
		};
	});
	
	// Update the network
	network.body.data.nodes.update(allNodes);
	network.body.data.edges.update(allEdges);
	
	// Clear stored colors
	originalNodeColors = {};
	originalEdgeColors = {};
}

function addOpacity(color, opacity) {
	// Convert hex color to rgba with opacity
	if (color.startsWith('#')) {
		const r = parseInt(color.slice(1, 3), 16);
		const g = parseInt(color.slice(3, 5), 16);
		const b = parseInt(color.slice(5, 7), 16);
		return `rgba(${r}, ${g}, ${b}, ${opacity})`;
	}
	// If already rgba, adjust opacity
	if (color.startsWith('rgba')) {
		return color.replace(/[\d.]+\)$/, `${opacity})`);
	}
	// If rgb, convert to rgba
	if (color.startsWith('rgb')) {
		return color.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
	}
	// Fallback
	return color;
}

// ============================================================================
// NODE DETAIL MODAL
// ============================================================================

let currentNodeId = null;

function handleNodeClick(id){
	currentNodeId = id;
	// Get node from network's dataset (has enhanced properties like community)
	const node = network.body.data.nodes.get(id);
	if (!node) return;
	
	// Open modal
	openNodeModal(node);
}

function openNodeModal(node) {
	const modal = document.getElementById('node-modal');
	const modalTitle = document.getElementById('modal-title');
	const modalContent = document.getElementById('modal-content');
	const viewPageBtn = document.getElementById('modal-view-page');
	
	// Set title
	modalTitle.textContent = `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} Details`;
	
	// Show loading
	modalContent.innerHTML = '<div class="modal-loading">Loading details...</div>';
	
	// Show modal
	modal.style.display = 'flex';
	
	// Load content based on node type
	setTimeout(() => {
		if (node.type === 'user') {
			renderUserDetails(node, modalContent);
			viewPageBtn.style.display = 'none';
		} else if (node.type === 'movie') {
			renderMovieDetails(node, modalContent);
			viewPageBtn.style.display = node.tmdb_id ? 'inline-block' : 'none';
		} else {
			renderGenericDetails(node, modalContent);
			viewPageBtn.style.display = 'none';
		}
	}, 100);
}

function renderCommunitySection(node) {
	if (!node.community || !node.community_name) {
		return '';
	}
	
	const communitiesData = currentData?.analytics?.communities?.communities || {};
	const communityInfo = communitiesData[node.community];
	
	if (!communityInfo) {
		return '';
	}
	
	const density = communityInfo.density !== undefined ? (communityInfo.density * 100).toFixed(0) + '%' : 'N/A';
	const internalEdges = communityInfo.internal_edges || 0;
	
	// Get community color
	const communityColors = [
		'#4299E1', '#F56565', '#48BB78', '#9F7AEA', '#ED8936', '#FFD700',
		'#00CED1', '#FF69B4', '#32CD32', '#FF6347', '#DA70D6', '#20B2AA',
		'#FF4500', '#1E90FF', '#228B22', '#DC143C', '#8A2BE2', '#FF1493'
	];
	const commNum = parseInt(node.community.replace('community_', ''));
	const colorIndex = commNum % communityColors.length;
	const color = communityColors[colorIndex];
	
	return `
		<div class="modal-section">
			<div class="modal-section-title">
				<span class="modal-section-icon">üåê</span>
				Community
			</div>
			<div class="community-detail">
				<div class="community-detail-header">
					<div class="community-color" style="background-color: ${color}; width: 20px; height: 20px; border-radius: 3px; border: 1px solid #ccc;"></div>
					<div class="community-detail-name">${node.community_name}</div>
				</div>
				<div class="community-detail-stats">
					<div class="detail-stat">
						<div class="detail-stat-label">Members</div>
						<div class="detail-stat-value">${node.community_size || 0}</div>
					</div>
					<div class="detail-stat">
						<div class="detail-stat-label">Density</div>
						<div class="detail-stat-value">${density}</div>
					</div>
					<div class="detail-stat">
						<div class="detail-stat-label">Internal Edges</div>
						<div class="detail-stat-value">${internalEdges}</div>
					</div>
				</div>
			</div>
		</div>
	`;
}

function renderUserDetails(node, container) {
	const influencer = currentData?.top_influencers?.users?.find(u => u.id === node.id);
	const influence = influencer?.influence_score || 0;
	const reviewCount = influencer?.review_count || node.reviews || 0;
	const displayLabel = node.fullLabel || node.label;
	
	// Determine icon HTML - use profile picture if available, otherwise emoji
	let iconHTML;
	if (node.profile_picture) {
		iconHTML = `<img src="${node.profile_picture}" alt="${displayLabel || 'User'}" />`;
	} else {
		iconHTML = '<div class="emoji">üë§</div>';
	}
	
	const html = `
		<div class="node-header">
			<div class="node-icon">${iconHTML}</div>
			<div class="node-info">
				<div class="node-name">${displayLabel || 'Unknown User'}</div>
				<div class="node-type">User</div>
				<div class="node-meta">
					<div class="meta-item">
						<div class="meta-label">Reviews</div>
						<div class="meta-value">${reviewCount}</div>
					</div>
					<div class="meta-item">
						<div class="meta-label">Influence Score</div>
						<div class="meta-value">${Math.round(influence)}</div>
					</div>
					<div class="meta-item">
						<div class="meta-label">Degree</div>
						<div class="meta-value">${node.degree || 0}</div>
					</div>
				</div>
			</div>
		</div>
		
		${influencer ? `
		<div class="modal-section">
			<div class="modal-section-title">
				<span class="modal-section-icon">‚≠ê</span>
				Influence Breakdown
			</div>
			<div class="influence-grid">
				<div class="influence-item">
					<div class="influence-label">Centrality (40%)</div>
					<div class="influence-value">${(influencer.centrality_component || 0).toFixed(1)}</div>
					<div class="influence-bar-container">
						<div class="influence-bar" style="width: ${Math.min(100, (influencer.centrality_component || 0))}%"></div>
					</div>
				</div>
				<div class="influence-item">
					<div class="influence-label">Activity (30%)</div>
					<div class="influence-value">${(influencer.activity_component || 0).toFixed(1)}</div>
					<div class="influence-bar-container">
						<div class="influence-bar" style="width: ${Math.min(100, (influencer.activity_component || 0))}%"></div>
					</div>
				</div>
				<div class="influence-item">
					<div class="influence-label">Quality (20%)</div>
					<div class="influence-value">${(influencer.quality_component || 0).toFixed(1)}</div>
					<div class="influence-bar-container">
						<div class="influence-bar" style="width: ${Math.min(100, (influencer.quality_component || 0))}%"></div>
					</div>
				</div>
				<div class="influence-item">
					<div class="influence-label">Recency (10%)</div>
					<div class="influence-value">${(influencer.recency_component || 0).toFixed(1)}</div>
					<div class="influence-bar-container">
						<div class="influence-bar" style="width: ${Math.min(100, (influencer.recency_component || 0))}%"></div>
					</div>
				</div>
			</div>
		</div>
		` : ''}
		
		${renderCommunitySection(node)}
		
		<div class="modal-section">
			<div class="modal-section-title">
				<span class="modal-section-icon">üîó</span>
				Connections (${getNodeConnections(node.id).length})
			</div>
			<div class="connections-list">
				${renderConnections(node.id)}
			</div>
		</div>
	`;
	
	container.innerHTML = html;
}

function renderMovieDetails(node, container) {
	const influencer = currentData?.top_influencers?.movies?.find(m => m.id === node.id);
	const influence = influencer?.influence_score || 0;
	const reviewCount = influencer?.review_count || node.reviews || 0;
	const displayLabel = node.fullLabel || node.label;
	
	const html = `
		<div class="node-header">
			<div class="node-icon">üé¨</div>
			<div class="node-info">
				<div class="node-name">${displayLabel || 'Unknown Movie'}</div>
				<div class="node-type">Movie</div>
				<div class="node-meta">
					<div class="meta-item">
						<div class="meta-label">Reviews</div>
						<div class="meta-value">${reviewCount}</div>
					</div>
					<div class="meta-item">
						<div class="meta-label">Influence Score</div>
						<div class="meta-value">${Math.round(influence)}</div>
					</div>
					${node.avg_rating ? `
					<div class="meta-item">
						<div class="meta-label">Avg Rating</div>
						<div class="meta-value">${node.avg_rating.toFixed(1)}</div>
					</div>
					` : ''}
				</div>
			</div>
		</div>
		
		${renderCommunitySection(node)}
		
		<div class="modal-section">
			<div class="modal-section-title">
				<span class="modal-section-icon">üîó</span>
				Connected Users (${getNodeConnections(node.id).filter(c => c.type === 'user').length})
			</div>
			<div class="connections-list">
				${renderConnections(node.id)}
			</div>
		</div>
	`;
	
	container.innerHTML = html;
}

function renderGenericDetails(node, container) {
	const typeIcons = {
		'genre': 'üé≠',
		'country': 'üåç',
		'director': 'üé•',
		'actor': 'üé¨',
		'crew': 'üîß'
	};
	
	const displayLabel = node.fullLabel || node.label;
	
	const html = `
		<div class="node-header">
			<div class="node-icon">${typeIcons[node.type] || 'üìç'}</div>
			<div class="node-info">
				<div class="node-name">${displayLabel || 'Unknown'}</div>
				<div class="node-type">${node.type}</div>
				<div class="node-meta">
					<div class="meta-item">
						<div class="meta-label">Connections</div>
						<div class="meta-value">${getNodeConnections(node.id).length}</div>
					</div>
					<div class="meta-item">
						<div class="meta-label">Degree</div>
						<div class="meta-value">${node.degree || 0}</div>
					</div>
				</div>
			</div>
		</div>
		
		${renderCommunitySection(node)}
		
		<div class="modal-section">
			<div class="modal-section-title">
				<span class="modal-section-icon">üîó</span>
				Connections (${getNodeConnections(node.id).length})
			</div>
			<div class="connections-list">
				${renderConnections(node.id)}
			</div>
		</div>
	`;
	
	container.innerHTML = html;
}

function getNodeConnections(nodeId) {
	const connections = [];
	currentData.edges.forEach(edge => {
		if (edge.source === nodeId || edge.from === nodeId) {
			const targetId = edge.target || edge.to;
			const targetNode = currentData.nodes.find(n => n.id === targetId);
			if (targetNode) connections.push(targetNode);
		} else if (edge.target === nodeId || edge.to === nodeId) {
			const sourceId = edge.source || edge.from;
			const sourceNode = currentData.nodes.find(n => n.id === sourceId);
			if (sourceNode) connections.push(sourceNode);
		}
	});
	return connections;
}

function renderConnections(nodeId) {
	const connections = getNodeConnections(nodeId);
	
	if (connections.length === 0) {
		return '<div class="influencer-placeholder">No connections</div>';
	}
	
	// Group by type
	const grouped = {};
	connections.forEach(conn => {
		if (!grouped[conn.type]) grouped[conn.type] = [];
		grouped[conn.type].push(conn);
	});
	
	let html = '';
	Object.keys(grouped).forEach(type => {
		const typeLabel = type.charAt(0).toUpperCase() + type.slice(1) + 's';
		html += `<div style="width:100%; font-size:11px; margin-top:8px; font-weight:bold;">${typeLabel} (${grouped[type].length}):</div>`;
		html += grouped[type].slice(0, 10).map(conn => `
			<span class="connection-badge" onclick="handleNodeClick('${conn.id}')" title="${conn.label}">
				${(conn.label || 'Unknown').substring(0, 20)}${conn.label?.length > 20 ? '...' : ''}
			</span>
		`).join('');
		if (grouped[type].length > 10) {
			html += `<span class="connection-badge" style="font-style:italic;">+${grouped[type].length - 10} more</span>`;
		}
	});
	
	return html;
}

function closeNodeModal() {
	const modal = document.getElementById('node-modal');
	modal.style.display = 'none';
	currentNodeId = null;
}

function viewNodePage() {
	const node = currentData.nodes.find(n => n.id === currentNodeId);
	if (node && node.type === 'movie' && node.tmdb_id) {
		window.open(`/movies/${node.tmdb_id}/`, '_blank');
	}
}

// Close modal on Escape key
document.addEventListener('keydown', (e) => {
	if (e.key === 'Escape') {
		closeNodeModal();
	}
});

document.getElementById('refresh-graph').addEventListener('click', loadGraph);
const chaosBtn = document.getElementById('chaos-mode-btn');
chaosBtn.addEventListener('click', ()=>{
	chaosModeEnabled = !chaosModeEnabled;
	chaosBtn.classList.toggle('active', chaosModeEnabled);
	chaosBtn.setAttribute('aria-pressed', chaosModeEnabled ? 'true':'false');
	if(chaosModeEnabled){ chaosBtn.title='Chaos Mode ON'; } else { chaosBtn.title='Chaos Mode OFF'; }
	document.querySelectorAll('.chaos-only').forEach(el=>{ el.style.display = chaosModeEnabled ? 'flex':'none'; });
	refreshFilterVisuals();
	loadGraph();
});

// auto refresh on checkbox change (debounced)
let filterChangeTimer=null;
document.querySelectorAll('.ng-filter').forEach(cb=>{
	cb.addEventListener('change', ()=>{
		if(filterChangeTimer) clearTimeout(filterChangeTimer);
		refreshFilterVisuals();
		// For client-side filtering, update immediately for node/edge type filters
		const param = cb.dataset.param;
		if(['users', 'movies', 'reviews', 'relationships', 'affinity'].includes(param) && currentData) {
			updateNetwork();
			updateStats(currentData.stats);
		} else {
			// For backend parameters, reload from server
			filterChangeTimer = setTimeout(()=>{ loadGraph(); }, 250);
		}
	});
});

// ========== ANALYTICS ALWAYS ACTIVE ==========
// Community coloring and influence-based sizing are always applied
// No manual toggles needed - analytics enhance the visualization automatically

// initial visual state
refreshFilterVisuals();

// ========== ALWAYS-ON PHYSICS ==========
// Physics are continuously enabled for smooth graph behavior
// No manual toggle needed - the graph adapts naturally to user interactions

document.addEventListener('DOMContentLoaded', ()=>{ initNetwork(); loadGraph(); });
window.addEventListener('resize', ()=> network && network.redraw());
</script>
{% endblock %}

